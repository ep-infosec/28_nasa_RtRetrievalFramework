# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _connor_solver.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_connor_solver')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_connor_solver')
    _connor_solver = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_connor_solver', [dirname(__file__)])
        except ImportError:
            import _connor_solver
            return _connor_solver
        try:
            _mod = imp.load_module('_connor_solver', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _connor_solver = swig_import_helper()
    del swig_import_helper
else:
    import _connor_solver
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


try:
    import weakref
    weakref_proxy = weakref.proxy
except __builtin__.Exception:
    weakref_proxy = lambda x: x


SHARED_PTR_DISOWN = _connor_solver.SHARED_PTR_DISOWN

def _new_from_init(cls, version, *args):
    '''For use with pickle, covers common case where we just store the
    arguments needed to create an object. See for example HdfFile'''
    if(cls.pickle_format_version() != version):
      raise RuntimeException("Class is expecting a pickled object with version number %d, but we found %d" % (cls.pickle_format_version(), version))
    inst = cls.__new__(cls)
    inst.__init__(*args)
    return inst

def _new_from_set(cls, version, *args):
    '''For use with pickle, covers common case where we use a set function 
    to assign the value'''
    if(cls.pickle_format_version() != version):
      raise RuntimeException("Class is expecting a pickled object with version number %d, but we found %d" % (cls.pickle_format_version(), version))
    inst = cls.__new__(cls)
    inst.__init__()
    inst.set(*args)
    return inst

import full_physics_swig.observer
import full_physics_swig.generic_object
class ObservableConnor(full_physics_swig.generic_object.GenericObject):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _connor_solver.delete_ObservableConnor
ObservableConnor.add_observer_and_keep_reference = new_instancemethod(_connor_solver.ObservableConnor_add_observer_and_keep_reference, None, ObservableConnor)
ObservableConnor.add_observer = new_instancemethod(_connor_solver.ObservableConnor_add_observer, None, ObservableConnor)
ObservableConnor.remove_observer = new_instancemethod(_connor_solver.ObservableConnor_remove_observer, None, ObservableConnor)
ObservableConnor_swigregister = _connor_solver.ObservableConnor_swigregister
ObservableConnor_swigregister(ObservableConnor)

class ConnorSolver(ObservableConnor):
    """

    C++ includes: connor_solver.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        FullPhysics::ConnorSolver::ConnorSolver(const boost::shared_ptr< CostFunction > &Cf, const boost::shared_ptr<
        ConvergenceCheck > &Conv, double Gamma_initial=0.0, const std::string
        &Save_test_data="")
        Constructor.

        This takes a CostFunction that we will minimize, a ConvergenceCheck to
        check for convergence, and optionally the initial value for gamma.

        See the comments above this class for the "save_test_data" argument.

        """
        _connor_solver.ConnorSolver_swiginit(self, _connor_solver.new_ConnorSolver(*args))

    def save_test_data(self, Fname):
        """

        void FullPhysics::ConnorSolver::save_test_data(const std::string &Fname)
        Set save_test_data argument, see explanation before class for this. 
        """
        return _connor_solver.ConnorSolver_save_test_data(self, Fname)


    def test_do_inversion(self, Fname, Dx, Kt_se_m1_k):
        """

        void ConnorSolver::test_do_inversion(const std::string &Fname, blitz::Array< double, 1 > &Dx,
        blitz::Array< double, 2 > &Kt_se_m1_k)
        Restore state previously saved, and run do_inversion.

        This is a backdoor to help do unit testing on do_inversion. 
        """
        return _connor_solver.ConnorSolver_test_do_inversion(self, Fname, Dx, Kt_se_m1_k)


    def solve(self, Initial_guess, Apriori, Apriori_cov):
        """

        bool ConnorSolver::solve(const blitz::Array< double, 1 > &Initial_guess, const blitz::Array<
        double, 1 > &Apriori, const blitz::Array< double, 2 > &Apriori_cov)
        This solves the least squares problem starting at the initial guess.

        We don't directly return the solution and related matrices, you can
        query this object for them after the solver has completed.

        Parameters:
        -----------

        Initial_guess:  The initial value of x_i

        Apriori:  The apriori value of x_i. Often but not always the same as
        the initial guess.

        Apriori_cov:  The covariance matrix of the apriori value.

        Returns true if we converge to a solution, false otherwise. 
        """
        return _connor_solver.ConnorSolver_solve(self, Initial_guess, Apriori, Apriori_cov)


    def _v_state(self, *args):
        """

        void ConnorSolver::state(const ConnorSolverState &S)
        Set the state of the ConnorSolver from a previously created
        ConnorSolverState.

        This is like from_stream, but works better with Python. 
        """
        return _connor_solver.ConnorSolver__v_state(self, *args)


    @property
    def state(self):
        return self._v_state()

    @state.setter
    def state(self, value):
      self._v_state(value)


    def _v_aposteriori_covariance_scaled(self):
        """

        Array< double, 2 > ConnorSolver::aposteriori_covariance_scaled() const
        Return a scaled a posteriori covariance matrix for last problem
        solved.

        This is scaled by sigma_ap. 
        """
        return _connor_solver.ConnorSolver__v_aposteriori_covariance_scaled(self)


    @property
    def aposteriori_covariance_scaled(self):
        return self._v_aposteriori_covariance_scaled()


    def _v_aposteriori_covariance(self):
        """

        Array< double, 2 > ConnorSolver::aposteriori_covariance() const
        Return a posteriori covariance matrix for last problem solved. 
        """
        return _connor_solver.ConnorSolver__v_aposteriori_covariance(self)


    @property
    def aposteriori_covariance(self):
        return self._v_aposteriori_covariance()


    def _v_x_solution_uncertainty(self):
        """

        blitz::Array< double, 1 > ConnorSolver::x_solution_uncertainty() const
        Return the uncertainty of x_solution, this is just the sqrt of the
        diagonal of the full aposteriori_covariance. 
        """
        return _connor_solver.ConnorSolver__v_x_solution_uncertainty(self)


    @property
    def x_solution_uncertainty(self):
        return self._v_x_solution_uncertainty()


    def _v_averaging_kernel(self):
        """

        Array< double, 2 > ConnorSolver::averaging_kernel() const
        Return averaging kernel for last problem solved. 
        """
        return _connor_solver.ConnorSolver__v_averaging_kernel(self)


    @property
    def averaging_kernel(self):
        return self._v_averaging_kernel()


    def _v_gamma_last_step(self):
        """

        double FullPhysics::ConnorSolver::gamma_last_step() const
        Levenberg-Marquardt parameter for last step we processed. 
        """
        return _connor_solver.ConnorSolver__v_gamma_last_step(self)


    @property
    def gamma_last_step(self):
        return self._v_gamma_last_step()


    def _v_number_iteration(self):
        """

        int FullPhysics::ConnorSolver::number_iteration() const
        Number of iterations for the last problem solved. 
        """
        return _connor_solver.ConnorSolver__v_number_iteration(self)


    @property
    def number_iteration(self):
        return self._v_number_iteration()


    def _v_number_divergent(self):
        """

        int FullPhysics::ConnorSolver::number_divergent() const
        Number of divergent steps for the last problem solved. 
        """
        return _connor_solver.ConnorSolver__v_number_divergent(self)


    @property
    def number_divergent(self):
        return self._v_number_divergent()


    def _v_outcome_flag(self):
        """

        int FullPhysics::ConnorSolver::outcome_flag() const
        Outcome flag. This is an integer version of FitStatistic::OUTCOME. 
        """
        return _connor_solver.ConnorSolver__v_outcome_flag(self)


    @property
    def outcome_flag(self):
        return self._v_outcome_flag()


    def _v_x_apriori(self):
        """

        blitz::Array<double, 1> FullPhysics::ConnorSolver::x_apriori() const
        Return the a priori of the last problem solved. 
        """
        return _connor_solver.ConnorSolver__v_x_apriori(self)


    @property
    def x_apriori(self):
        return self._v_x_apriori()


    def _v_x_apriori_uncertainty(self):
        """

        blitz::Array<double, 1> FullPhysics::ConnorSolver::x_apriori_uncertainty() const
        Return the uncertainty of the apriori of the last problem solved.

        This is the sqrt of the diagonal of the a priori covariance matrix. 
        """
        return _connor_solver.ConnorSolver__v_x_apriori_uncertainty(self)


    @property
    def x_apriori_uncertainty(self):
        return self._v_x_apriori_uncertainty()


    def _v_x_solution(self):
        """

        virtual blitz::Array<double, 1> FullPhysics::ConnorSolver::x_solution() const

        """
        return _connor_solver.ConnorSolver__v_x_solution(self)


    @property
    def x_solution(self):
        return self._v_x_solution()


    def _v_x_solution_zero_unused(self):
        """

        blitz::Array< double, 1 > ConnorSolver::x_solution_zero_unused() const
        Return the solution to the last problem solved.

        We set unused parameters to 0 (this makes sense for our current
        forward model, we may want to do something more sophisticated in the
        future). 
        """
        return _connor_solver.ConnorSolver__v_x_solution_zero_unused(self)


    @property
    def x_solution_zero_unused(self):
        return self._v_x_solution_zero_unused()


    def _v_apriori_covariance(self):
        """

        Array< double, 2 > ConnorSolver::apriori_covariance() const
        Apriori covariance matrix. 
        """
        return _connor_solver.ConnorSolver__v_apriori_covariance(self)


    @property
    def apriori_covariance(self):
        return self._v_apriori_covariance()


    def _v_jacobian(self):
        """

        virtual blitz::Array<double, 2> FullPhysics::ConnorSolver::jacobian() const
        Return the last jacobian calculated.

        Note that this is not the jacobian calculated at the final solution
        x_sol, but rather is the for the iteration right before x_sol. Never
        the less this can be used as an approximation to the final Jacobian.

        We currently don't calculate the final Jacobian because each iteration
        of the CostFunction can be rather expensive to calculate. We can
        revisit this if necessary in the future. 
        """
        return _connor_solver.ConnorSolver__v_jacobian(self)


    @property
    def jacobian(self):
        return self._v_jacobian()


    def _v_fit_statistic(self):
        """

        virtual FitStatistic FullPhysics::ConnorSolver::fit_statistic() const
        Return fit results for solution to last problem solved. 
        """
        return _connor_solver.ConnorSolver__v_fit_statistic(self)


    @property
    def fit_statistic(self):
        return self._v_fit_statistic()


    def _v_residual(self):
        """

        virtual blitz::Array<double, 1> FullPhysics::ConnorSolver::residual() const
        Return residual for solution to last problem solved. 
        """
        return _connor_solver.ConnorSolver__v_residual(self)


    @property
    def residual(self):
        return self._v_residual()


    def _v_residual_covariance_diagonal(self):
        """

        virtual blitz::Array<double, 1> FullPhysics::ConnorSolver::residual_covariance_diagonal() const
        Return diagonal of covariance matrix of residual for solution to last
        problem solved. 
        """
        return _connor_solver.ConnorSolver__v_residual_covariance_diagonal(self)


    @property
    def residual_covariance_diagonal(self):
        return self._v_residual_covariance_diagonal()


    def _v_apriori_covariance_inv_norm(self):
        """

        virtual blitz::Array<double, 2> FullPhysics::ConnorSolver::apriori_covariance_inv_norm() const
        Return normalized apriori covariance inverse matrix. 
        """
        return _connor_solver.ConnorSolver__v_apriori_covariance_inv_norm(self)


    @property
    def apriori_covariance_inv_norm(self):
        return self._v_apriori_covariance_inv_norm()


    def _v_cost_function(self):
        """

        boost::shared_ptr<CostFunction> FullPhysics::ConnorSolver::cost_function() const
        Cost function. 
        """
        return _connor_solver.ConnorSolver__v_cost_function(self)


    @property
    def cost_function(self):
        return self._v_cost_function()


    def _v_convergence_check(self):
        """

        boost::shared_ptr<ConvergenceCheck> FullPhysics::ConnorSolver::convergence_check() const
        The convergence check object. 
        """
        return _connor_solver.ConnorSolver__v_convergence_check(self)


    @property
    def convergence_check(self):
        return self._v_convergence_check()

    __swig_destroy__ = _connor_solver.delete_ConnorSolver
ConnorSolver.save_test_data = new_instancemethod(_connor_solver.ConnorSolver_save_test_data, None, ConnorSolver)
ConnorSolver.test_do_inversion = new_instancemethod(_connor_solver.ConnorSolver_test_do_inversion, None, ConnorSolver)
ConnorSolver.solve = new_instancemethod(_connor_solver.ConnorSolver_solve, None, ConnorSolver)
ConnorSolver._v_state = new_instancemethod(_connor_solver.ConnorSolver__v_state, None, ConnorSolver)
ConnorSolver._v_aposteriori_covariance_scaled = new_instancemethod(_connor_solver.ConnorSolver__v_aposteriori_covariance_scaled, None, ConnorSolver)
ConnorSolver._v_aposteriori_covariance = new_instancemethod(_connor_solver.ConnorSolver__v_aposteriori_covariance, None, ConnorSolver)
ConnorSolver._v_x_solution_uncertainty = new_instancemethod(_connor_solver.ConnorSolver__v_x_solution_uncertainty, None, ConnorSolver)
ConnorSolver._v_averaging_kernel = new_instancemethod(_connor_solver.ConnorSolver__v_averaging_kernel, None, ConnorSolver)
ConnorSolver._v_gamma_last_step = new_instancemethod(_connor_solver.ConnorSolver__v_gamma_last_step, None, ConnorSolver)
ConnorSolver._v_number_iteration = new_instancemethod(_connor_solver.ConnorSolver__v_number_iteration, None, ConnorSolver)
ConnorSolver._v_number_divergent = new_instancemethod(_connor_solver.ConnorSolver__v_number_divergent, None, ConnorSolver)
ConnorSolver._v_outcome_flag = new_instancemethod(_connor_solver.ConnorSolver__v_outcome_flag, None, ConnorSolver)
ConnorSolver._v_x_apriori = new_instancemethod(_connor_solver.ConnorSolver__v_x_apriori, None, ConnorSolver)
ConnorSolver._v_x_apriori_uncertainty = new_instancemethod(_connor_solver.ConnorSolver__v_x_apriori_uncertainty, None, ConnorSolver)
ConnorSolver._v_x_solution = new_instancemethod(_connor_solver.ConnorSolver__v_x_solution, None, ConnorSolver)
ConnorSolver._v_x_solution_zero_unused = new_instancemethod(_connor_solver.ConnorSolver__v_x_solution_zero_unused, None, ConnorSolver)
ConnorSolver._v_apriori_covariance = new_instancemethod(_connor_solver.ConnorSolver__v_apriori_covariance, None, ConnorSolver)
ConnorSolver._v_jacobian = new_instancemethod(_connor_solver.ConnorSolver__v_jacobian, None, ConnorSolver)
ConnorSolver._v_fit_statistic = new_instancemethod(_connor_solver.ConnorSolver__v_fit_statistic, None, ConnorSolver)
ConnorSolver._v_residual = new_instancemethod(_connor_solver.ConnorSolver__v_residual, None, ConnorSolver)
ConnorSolver._v_residual_covariance_diagonal = new_instancemethod(_connor_solver.ConnorSolver__v_residual_covariance_diagonal, None, ConnorSolver)
ConnorSolver._v_apriori_covariance_inv_norm = new_instancemethod(_connor_solver.ConnorSolver__v_apriori_covariance_inv_norm, None, ConnorSolver)
ConnorSolver._v_cost_function = new_instancemethod(_connor_solver.ConnorSolver__v_cost_function, None, ConnorSolver)
ConnorSolver._v_convergence_check = new_instancemethod(_connor_solver.ConnorSolver__v_convergence_check, None, ConnorSolver)
ConnorSolver.save_state = new_instancemethod(_connor_solver.ConnorSolver_save_state, None, ConnorSolver)
ConnorSolver.load_state = new_instancemethod(_connor_solver.ConnorSolver_load_state, None, ConnorSolver)
ConnorSolver_swigregister = _connor_solver.ConnorSolver_swigregister
ConnorSolver_swigregister(ConnorSolver)

class ConnorSolverState(full_physics_swig.generic_object.GenericObject):
    """

    Class that saves the state of a ConnorSolver.

    C++ includes: connor_solver.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, X_i, X_a, Apriori_cov_scaled, Sa_m1_scaled, Sigma_ap, Gamma, Gamma_last_step, Gamma_intial, Residual, Se, K, Kt_se_m1_k, Dx, Fstat):
        """

        FullPhysics::ConnorSolverState::ConnorSolverState(const blitz::Array< double, 1 > &X_i, const blitz::Array< double, 1 >
        &X_a, const blitz::Array< double, 2 > &Apriori_cov_scaled, const
        blitz::Array< double, 2 > &Sa_m1_scaled, const blitz::Array< double, 1
        > &Sigma_ap, double Gamma, double Gamma_last_step, double
        Gamma_intial, const blitz::Array< double, 1 > &Residual, const
        blitz::Array< double, 1 > &Se, const blitz::Array< double, 2 > &K,
        const blitz::Array< double, 2 > &Kt_se_m1_k, const blitz::Array<
        double, 1 > &Dx, const FitStatistic &Fstat)

        """
        _connor_solver.ConnorSolverState_swiginit(self, _connor_solver.new_ConnorSolverState(X_i, X_a, Apriori_cov_scaled, Sa_m1_scaled, Sigma_ap, Gamma, Gamma_last_step, Gamma_intial, Residual, Se, K, Kt_se_m1_k, Dx, Fstat))

    def _v_x_i(self):
        """

        const blitz::Array<double, 1>& FullPhysics::ConnorSolverState::x_i() const

        """
        return _connor_solver.ConnorSolverState__v_x_i(self)


    @property
    def x_i(self):
        return self._v_x_i()


    def _v_x_a(self):
        """

        const blitz::Array<double, 1>& FullPhysics::ConnorSolverState::x_a() const

        """
        return _connor_solver.ConnorSolverState__v_x_a(self)


    @property
    def x_a(self):
        return self._v_x_a()


    def _v_apriori_cov_scaled(self):
        """

        const blitz::Array<double, 2>& FullPhysics::ConnorSolverState::apriori_cov_scaled() const

        """
        return _connor_solver.ConnorSolverState__v_apriori_cov_scaled(self)


    @property
    def apriori_cov_scaled(self):
        return self._v_apriori_cov_scaled()


    def _v_sa_m1_scaled(self):
        """

        const blitz::Array<double, 2>& FullPhysics::ConnorSolverState::sa_m1_scaled() const

        """
        return _connor_solver.ConnorSolverState__v_sa_m1_scaled(self)


    @property
    def sa_m1_scaled(self):
        return self._v_sa_m1_scaled()


    def _v_sigma_ap(self):
        """

        const blitz::Array<double, 1>& FullPhysics::ConnorSolverState::sigma_ap() const

        """
        return _connor_solver.ConnorSolverState__v_sigma_ap(self)


    @property
    def sigma_ap(self):
        return self._v_sigma_ap()


    def _v_gamma(self):
        """

        double FullPhysics::ConnorSolverState::gamma() const

        """
        return _connor_solver.ConnorSolverState__v_gamma(self)


    @property
    def gamma(self):
        return self._v_gamma()


    def _v_gamma_last_step(self):
        """

        double FullPhysics::ConnorSolverState::gamma_last_step() const

        """
        return _connor_solver.ConnorSolverState__v_gamma_last_step(self)


    @property
    def gamma_last_step(self):
        return self._v_gamma_last_step()


    def _v_gamma_initial(self):
        """

        double FullPhysics::ConnorSolverState::gamma_initial() const

        """
        return _connor_solver.ConnorSolverState__v_gamma_initial(self)


    @property
    def gamma_initial(self):
        return self._v_gamma_initial()


    def _v_residual(self):
        """

        const blitz::Array<double, 1>& FullPhysics::ConnorSolverState::residual() const

        """
        return _connor_solver.ConnorSolverState__v_residual(self)


    @property
    def residual(self):
        return self._v_residual()


    def _v_k(self):
        """

        const blitz::Array<double, 2>& FullPhysics::ConnorSolverState::k() const

        """
        return _connor_solver.ConnorSolverState__v_k(self)


    @property
    def k(self):
        return self._v_k()


    def _v_kt_se_m1_k(self):
        """

        const blitz::Array<double, 2>& FullPhysics::ConnorSolverState::kt_se_m1_k() const

        """
        return _connor_solver.ConnorSolverState__v_kt_se_m1_k(self)


    @property
    def kt_se_m1_k(self):
        return self._v_kt_se_m1_k()


    def _v_se(self):
        """

        const blitz::Array<double, 1>& FullPhysics::ConnorSolverState::se() const

        """
        return _connor_solver.ConnorSolverState__v_se(self)


    @property
    def se(self):
        return self._v_se()


    def _v_dx(self):
        """

        const blitz::Array<double, 1>& FullPhysics::ConnorSolverState::dx() const

        """
        return _connor_solver.ConnorSolverState__v_dx(self)


    @property
    def dx(self):
        return self._v_dx()


    def _v_fstat(self):
        """

        const FitStatistic& FullPhysics::ConnorSolverState::fstat() const

        """
        return _connor_solver.ConnorSolverState__v_fstat(self)


    @property
    def fstat(self):
        return self._v_fstat()


    @classmethod
    def pickle_format_version(cls):
      return 1

    def __reduce__(self):
      return _new_from_init, (self.__class__, 1, self.x_i,self.x_a,self.apriori_cov_scaled,self.sa_m1_scaled,self.sigma_ap,self.gamma,self.gamma_last_step,self.gamma_initial,self.residual,self.se,self.k,self.kt_se_m1_k,self.dx,self.fstat)

    __swig_destroy__ = _connor_solver.delete_ConnorSolverState
ConnorSolverState.__str__ = new_instancemethod(_connor_solver.ConnorSolverState___str__, None, ConnorSolverState)
ConnorSolverState._v_x_i = new_instancemethod(_connor_solver.ConnorSolverState__v_x_i, None, ConnorSolverState)
ConnorSolverState._v_x_a = new_instancemethod(_connor_solver.ConnorSolverState__v_x_a, None, ConnorSolverState)
ConnorSolverState._v_apriori_cov_scaled = new_instancemethod(_connor_solver.ConnorSolverState__v_apriori_cov_scaled, None, ConnorSolverState)
ConnorSolverState._v_sa_m1_scaled = new_instancemethod(_connor_solver.ConnorSolverState__v_sa_m1_scaled, None, ConnorSolverState)
ConnorSolverState._v_sigma_ap = new_instancemethod(_connor_solver.ConnorSolverState__v_sigma_ap, None, ConnorSolverState)
ConnorSolverState._v_gamma = new_instancemethod(_connor_solver.ConnorSolverState__v_gamma, None, ConnorSolverState)
ConnorSolverState._v_gamma_last_step = new_instancemethod(_connor_solver.ConnorSolverState__v_gamma_last_step, None, ConnorSolverState)
ConnorSolverState._v_gamma_initial = new_instancemethod(_connor_solver.ConnorSolverState__v_gamma_initial, None, ConnorSolverState)
ConnorSolverState._v_residual = new_instancemethod(_connor_solver.ConnorSolverState__v_residual, None, ConnorSolverState)
ConnorSolverState._v_k = new_instancemethod(_connor_solver.ConnorSolverState__v_k, None, ConnorSolverState)
ConnorSolverState._v_kt_se_m1_k = new_instancemethod(_connor_solver.ConnorSolverState__v_kt_se_m1_k, None, ConnorSolverState)
ConnorSolverState._v_se = new_instancemethod(_connor_solver.ConnorSolverState__v_se, None, ConnorSolverState)
ConnorSolverState._v_dx = new_instancemethod(_connor_solver.ConnorSolverState__v_dx, None, ConnorSolverState)
ConnorSolverState._v_fstat = new_instancemethod(_connor_solver.ConnorSolverState__v_fstat, None, ConnorSolverState)
ConnorSolverState_swigregister = _connor_solver.ConnorSolverState_swigregister
ConnorSolverState_swigregister(ConnorSolverState)

class ObserverConnorSolver(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        if self.__class__ == ObserverConnorSolver:
            _self = None
        else:
            _self = self
        _connor_solver.ObserverConnorSolver_swiginit(self, _connor_solver.new_ObserverConnorSolver(_self, ))
    def __disown__(self):
        self.this.disown()
        _connor_solver.disown_ObserverConnorSolver(self)
        return weakref_proxy(self)
ObserverConnorSolver.notify_add = new_instancemethod(_connor_solver.ObserverConnorSolver_notify_add, None, ObserverConnorSolver)
ObserverConnorSolver.notify_remove = new_instancemethod(_connor_solver.ObserverConnorSolver_notify_remove, None, ObserverConnorSolver)
ObserverConnorSolver.notify_update = new_instancemethod(_connor_solver.ObserverConnorSolver_notify_update, None, ObserverConnorSolver)
ObserverConnorSolver_swigregister = _connor_solver.ObserverConnorSolver_swigregister
ObserverConnorSolver_swigregister(ObserverConnorSolver)



