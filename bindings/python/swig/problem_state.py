# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _problem_state.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_problem_state')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_problem_state')
    _problem_state = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_problem_state', [dirname(__file__)])
        except ImportError:
            import _problem_state
            return _problem_state
        try:
            _mod = imp.load_module('_problem_state', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _problem_state = swig_import_helper()
    del swig_import_helper
else:
    import _problem_state
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


try:
    import weakref
    weakref_proxy = weakref.proxy
except __builtin__.Exception:
    weakref_proxy = lambda x: x


SHARED_PTR_DISOWN = _problem_state.SHARED_PTR_DISOWN

def _new_from_init(cls, version, *args):
    '''For use with pickle, covers common case where we just store the
    arguments needed to create an object. See for example HdfFile'''
    if(cls.pickle_format_version() != version):
      raise RuntimeException("Class is expecting a pickled object with version number %d, but we found %d" % (cls.pickle_format_version(), version))
    inst = cls.__new__(cls)
    inst.__init__(*args)
    return inst

def _new_from_set(cls, version, *args):
    '''For use with pickle, covers common case where we use a set function 
    to assign the value'''
    if(cls.pickle_format_version() != version):
      raise RuntimeException("Class is expecting a pickled object with version number %d, but we found %d" % (cls.pickle_format_version(), version))
    inst = cls.__new__(cls)
    inst.__init__()
    inst.set(*args)
    return inst

import full_physics_swig.generic_object
class ProblemState(full_physics_swig.generic_object.GenericObject):
    """

    The base class for all problem states.

    ProblemState is the base class for the state of all optimization
    problems.

    An optimization problem is just a cost function to be minimized.
    Therefore, in its simplest form, the state of an optimization problem
    is the point in the parameter space where the cost function is
    currently evaluated. In other words, given a point in the parameter
    space, everything else needed (cost function value and its derivatives
    if needed) can be determined. Therefore, in the context of our
    optimization problem we may also use "problem state" to refer to the
    point in the parameter space where the optimization related cost
    function is evaluated.

    However, the role of this class is expanded and has resulted in a
    class hierarchy rooted at ProblemState class. It could be very
    expensive to evaluate some cost functions and/or their derivatives;
    therefore, it is desirable to store computationally expensive
    components of a cost function after evaluation. The classes in the
    class hierarchy (rooted at ProblemState class) enable maintaining of
    the problem state (the current point in the parameter space) and
    computationally expensive components of the cost function just in case
    they are needed repeatedly.

    This hierarchy provides a systematic way to store an optimization
    problem state and the related computationally expensive components,

    delete all stored components of the cost function when the state
    changes, and

    determine when a new state is different enough from the current state
    to be considered a change in the state.

    All optimization problem classes in the class hierarchy rooted at
    CostFunc class must directly or indirectly inherit at least
    ProblemState class. Given that CostFunc is derived form ProblemState,
    then all classes in the problem class hierarchy will inherit CostFunc
    automatically. However, a problem class may also optionally inherit
    another appropriate problem state class in ProblemState class
    hierarchy.

    C++ includes: problem_state.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _problem_state.delete_ProblemState

    def set(self, s):
        """

        virtual void FullPhysics::ProblemState::set(const ProblemState &s)
        Makes self a copy of the input state.

        This method makes the object, for which it is called, a copy of the
        input state.

        Parameters:
        -----------

        s:  another ProblemState 
        """
        return _problem_state.ProblemState_set(self, s)


    def clear(self):
        """

        virtual void FullPhysics::ProblemState::clear()
        Deletes data contents.

        This method deletes state. It must be reimplemented by other classes
        derived from this class to delete other saved components associated
        with the state as well. 
        """
        return _problem_state.ProblemState_clear(self)


    def parameters_different(self, x):
        """

        bool ProblemState::parameters_different(const blitz::Array< double, 1 > &x) const
        Checks whether or not new input parameters are different from the
        current ones.

        The methods checks to see whether or not the new input parameters
        (point in the parameter space) are different from the parameters
        maintained by the object for which the method is called.

        If the size of the input parameters is not equal to the expected size
        of the parameters (check comments on expected_parameter_size), then
        the method will throw an exception.

        If the object for which the method is called has currently no
        parameters set, then the method returns true. Otherwise, the method
        uses some algorithm to figure out when the difference is "big
        enough" to be considered different. If the method determines that the
        new input parameters are different from the current parameters, then
        it returns true, otherwise, it returns false.

        Parameters:
        -----------

        x:  New set of parameters 
        """
        return _problem_state.ProblemState_parameters_different(self, x)


    def _v_parameters(self, *args):
        """

        virtual blitz::Array<double, 1> FullPhysics::ProblemState::parameters() const
        Returns the current parameters.

        Current parameter 
        """
        return _problem_state.ProblemState__v_parameters(self, *args)


    @property
    def parameters(self):
        return self._v_parameters()

    @parameters.setter
    def parameters(self, value):
      self._v_parameters(value)


    def _v_parameter_size(self):
        """

        virtual int FullPhysics::ProblemState::parameter_size() const
        Returns the size of the parameters.

        Size of parameters 
        """
        return _problem_state.ProblemState__v_parameter_size(self)


    @property
    def parameter_size(self):
        return self._v_parameter_size()


    def _v_expected_parameter_size(self):
        """

        virtual int FullPhysics::ProblemState::expected_parameter_size() const
        Returns the expected size of the parameters.

        This method must be reimplemented by the problem class the inherits
        ProblemState. It is only in the context of an optimization problem
        that one knows what the size of the parameters (number of the
        dimensions of the parameter space) is.

        This method is intentionally implemented here instead of being left as
        a pure virtual method. The intention is that the user to be able to
        create an object of this class or its derived classes for the purpose
        of preserving an older state of a problem if needed.

        Expected size of parameters 
        """
        return _problem_state.ProblemState__v_expected_parameter_size(self)


    @property
    def expected_parameter_size(self):
        return self._v_expected_parameter_size()


    def assert_parameter_set_correctly(self):
        """

        virtual void FullPhysics::ProblemState::assert_parameter_set_correctly() const
        Checks that the parameters are set correctly.

        This method checks to see whether or not the parameters are set
        correctly. If the parameters are not set correctly then it throws an
        exception. 
        """
        return _problem_state.ProblemState_assert_parameter_set_correctly(self)


    def assert_parameter_correct(self, x):
        """

        void ProblemState::assert_parameter_correct(const blitz::Array< double, 1 > &x) const
        Checks that the new input parameters are correct.

        This method checks to see whether or not the new input parameters are
        correct. If the parameters are not correct then it throws an
        exception. 
        """
        return _problem_state.ProblemState_assert_parameter_correct(self, x)

ProblemState.set = new_instancemethod(_problem_state.ProblemState_set, None, ProblemState)
ProblemState.clear = new_instancemethod(_problem_state.ProblemState_clear, None, ProblemState)
ProblemState.parameters_different = new_instancemethod(_problem_state.ProblemState_parameters_different, None, ProblemState)
ProblemState._v_parameters = new_instancemethod(_problem_state.ProblemState__v_parameters, None, ProblemState)
ProblemState._v_parameter_size = new_instancemethod(_problem_state.ProblemState__v_parameter_size, None, ProblemState)
ProblemState._v_expected_parameter_size = new_instancemethod(_problem_state.ProblemState__v_expected_parameter_size, None, ProblemState)
ProblemState.assert_parameter_set_correctly = new_instancemethod(_problem_state.ProblemState_assert_parameter_set_correctly, None, ProblemState)
ProblemState.assert_parameter_correct = new_instancemethod(_problem_state.ProblemState_assert_parameter_correct, None, ProblemState)
ProblemState.__str__ = new_instancemethod(_problem_state.ProblemState___str__, None, ProblemState)
ProblemState_swigregister = _problem_state.ProblemState_swigregister
ProblemState_swigregister(ProblemState)



