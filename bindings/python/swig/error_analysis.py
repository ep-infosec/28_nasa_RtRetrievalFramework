# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _error_analysis.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_error_analysis')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_error_analysis')
    _error_analysis = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_error_analysis', [dirname(__file__)])
        except ImportError:
            import _error_analysis
            return _error_analysis
        try:
            _mod = imp.load_module('_error_analysis', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _error_analysis = swig_import_helper()
    del swig_import_helper
else:
    import _error_analysis
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


try:
    import weakref
    weakref_proxy = weakref.proxy
except __builtin__.Exception:
    weakref_proxy = lambda x: x


SHARED_PTR_DISOWN = _error_analysis.SHARED_PTR_DISOWN

def _new_from_init(cls, version, *args):
    '''For use with pickle, covers common case where we just store the
    arguments needed to create an object. See for example HdfFile'''
    if(cls.pickle_format_version() != version):
      raise RuntimeException("Class is expecting a pickled object with version number %d, but we found %d" % (cls.pickle_format_version(), version))
    inst = cls.__new__(cls)
    inst.__init__(*args)
    return inst

def _new_from_set(cls, version, *args):
    '''For use with pickle, covers common case where we use a set function 
    to assign the value'''
    if(cls.pickle_format_version() != version):
      raise RuntimeException("Class is expecting a pickled object with version number %d, but we found %d" % (cls.pickle_format_version(), version))
    inst = cls.__new__(cls)
    inst.__init__()
    inst.set(*args)
    return inst

import full_physics_swig.generic_object
import full_physics_swig.observer
import full_physics_swig.model_measure
import full_physics_swig.model_state
import full_physics_swig.problem_state
import full_physics_swig.rt_atmosphere
import full_physics_swig.state_vector
import full_physics_swig.aerosol
class ErrorAnalysis(full_physics_swig.generic_object.GenericObject):
    """

    This calculates a variety of values to help with the error analysis of
    a Level 2 Full Physics Run.

    We currently support both a ConnorSolver or the more general
    MaxAPosteriori. The error analysis is almost identical, we just get
    parameters from one or the other source.

    Note that the current implementation of this class repeatedly
    calculates certain values (e.g., hmat is calculated each time it is
    used). We could cache values if needed, with code handling the
    clearing of the cache when absorber or solver changes. But right now
    the error analysis is only done a hand full of times (in a normal run,
    just at the end. With iteration output, at each iteration).
    Performance is perfectly acceptable, even with duplicate calculations.
    We can revisit this if performance ever becomes an issue.

    C++ includes: error_analysis.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """

        ErrorAnalysis::ErrorAnalysis(const boost::shared_ptr< MaxAPosteriori > &Max_a_posteriori, const
        boost::shared_ptr< RtAtmosphere > &Atm, const boost::shared_ptr<
        ForwardModel > &Fm)
        This is variation of ErrorAnalysis that takes a general RtAtmosphere.

        This will fail for anything other than a AtmosphereOco, however it is
        convenient to have this for use with Lua (which has much more limited
        knowledge of the class structure). 
        """
        _error_analysis.ErrorAnalysis_swiginit(self, _error_analysis.new_ErrorAnalysis(*args))

    def residual_sum_sq(self, Band):
        """

        double FullPhysics::ErrorAnalysis::residual_sum_sq(int Band) const
        Return the sum of the squares of the residual for the given band. 
        """
        return _error_analysis.ErrorAnalysis_residual_sum_sq(self, Band)


    def residual_mean_sq(self, Band):
        """

        double FullPhysics::ErrorAnalysis::residual_mean_sq(int Band) const
        Return the residual mean square for the O2 band. 
        """
        return _error_analysis.ErrorAnalysis_residual_mean_sq(self, Band)


    def reduced_chisq(self, Band):
        """

        double FullPhysics::ErrorAnalysis::reduced_chisq(int Band) const
        Return the reduced chisq for band. 
        """
        return _error_analysis.ErrorAnalysis_reduced_chisq(self, Band)


    def relative_residual_mean_sq(self, Band):
        """

        double FullPhysics::ErrorAnalysis::relative_residual_mean_sq(int Band) const
        Return the relative residual mean square for the given band. 
        """
        return _error_analysis.ErrorAnalysis_relative_residual_mean_sq(self, Band)


    def signal(self, band):
        """

        double ErrorAnalysis::signal(int band) const
        Calculate an approximation to the size of the continuum signal where
        there is no significant atmosphere absorption.

        We approximate this by finding the 10 highest radiance values and
        averaging them. 
        """
        return _error_analysis.ErrorAnalysis_signal(self, band)


    def noise(self, band):
        """

        double ErrorAnalysis::noise(int band) const
        Helper class for sort done in noise.

        Calculate an approximation to the size noise of the continuum signal
        where there is no significant atmosphere absorption. We approximate
        this by finding the 10 highest radiance values and averaging their
        noise. 
        """
        return _error_analysis.ErrorAnalysis_noise(self, band)


    def chisq_measure_norm(self, Residual, Residual_cov_diag):
        """

        double FullPhysics::ErrorAnalysis::chisq_measure_norm(const blitz::Array< double, 1 > &Residual, const blitz::Array<
        double, 1 > &Residual_cov_diag) const
        return chisq_measure_norm for the given data. 
        """
        return _error_analysis.ErrorAnalysis_chisq_measure_norm(self, Residual, Residual_cov_diag)


    def _v_xco2_measurement_error(self):
        """

        double ErrorAnalysis::xco2_measurement_error() const
        Calculate XCO2 measurement error.

        This is equation 3-106 in the ATB 
        """
        return _error_analysis.ErrorAnalysis__v_xco2_measurement_error(self)


    @property
    def xco2_measurement_error(self):
        return self._v_xco2_measurement_error()


    def _v_xco2_smoothing_error(self):
        """

        double ErrorAnalysis::xco2_smoothing_error() const
        Calculate XCO2 smoothing error.

        This is equation 3-107 in the ATB 
        """
        return _error_analysis.ErrorAnalysis__v_xco2_smoothing_error(self)


    @property
    def xco2_smoothing_error(self):
        return self._v_xco2_smoothing_error()


    def _v_xco2_uncertainty(self):
        """

        double ErrorAnalysis::xco2_uncertainty() const
        XCO2 uncertainty. 
        """
        return _error_analysis.ErrorAnalysis__v_xco2_uncertainty(self)


    @property
    def xco2_uncertainty(self):
        return self._v_xco2_uncertainty()


    def _v_xco2_interference_error(self):
        """

        double ErrorAnalysis::xco2_interference_error() const
        Calculate XCO2 interference error.

        This is equation 3-108 in the ATB 
        """
        return _error_analysis.ErrorAnalysis__v_xco2_interference_error(self)


    @property
    def xco2_interference_error(self):
        return self._v_xco2_interference_error()


    def _v_xco2_gain_vector(self):
        """

        Array< double, 1 > ErrorAnalysis::xco2_gain_vector() const
        This calculates xco2_gain_vector.

        It is formally the partial derivative of retrieved XCO2 with respect
        to input radiance. It has the same size & shape as
        SpectralParameters/measured_radiance. That is, one entry per sounding,
        and each sounding has a vector of length m, which is the total # of
        channels across the 3 bands.

        It can be calculated nearly exactly by using the posterior error
        covariance matrix S, the jacobian matrix K, the prior error covariance
        matrix Sy, and the pressure weighting function h. It is given by

        (h^t, 0^t) S K^t Sy^-1

        Where ^-1 denotes inverse, ^t denotes matrix transpose. The thing on
        the front in parentheses is a row vector of length n, where n is the
        number of state vector elements; it has h for its first 20 elements,
        and 0 after that. Is is formally the object that transforms the
        retrieved state vector into XCO2. Sy^-1 is calculated internally in
        the code, but it is also easy to construct. It is a diagonal (m,m)
        matrix with 1/sigma^2 down the diagonal, where sigma is the 1-sigma
        prior radiance uncertainty for each channel. K is the (n,m) matrix of
        jacobians, and S is the (n,n) posterior error covariance matrix. 
        """
        return _error_analysis.ErrorAnalysis__v_xco2_gain_vector(self)


    @property
    def xco2_gain_vector(self):
        return self._v_xco2_gain_vector()


    def _v_xco2_uncert_noise(self):
        """

        double FullPhysics::ErrorAnalysis::xco2_uncert_noise() const
        Calculate xco2_uncert_noise. 
        """
        return _error_analysis.ErrorAnalysis__v_xco2_uncert_noise(self)


    @property
    def xco2_uncert_noise(self):
        return self._v_xco2_uncert_noise()


    def _v_xco2_uncert_smooth(self):
        """

        double FullPhysics::ErrorAnalysis::xco2_uncert_smooth() const
        Calculate xco2_uncert_smooth. 
        """
        return _error_analysis.ErrorAnalysis__v_xco2_uncert_smooth(self)


    @property
    def xco2_uncert_smooth(self):
        return self._v_xco2_uncert_smooth()


    def _v_xco2_uncert_interf(self):
        """

        double FullPhysics::ErrorAnalysis::xco2_uncert_interf() const
        Calculate xco2_uncert_interf. 
        """
        return _error_analysis.ErrorAnalysis__v_xco2_uncert_interf(self)


    @property
    def xco2_uncert_interf(self):
        return self._v_xco2_uncert_interf()


    def _v_degrees_of_freedom_full_vector(self):
        """

        double FullPhysics::ErrorAnalysis::degrees_of_freedom_full_vector() const
        Calculate the degrees of freedom for the full state vector.

        This is just the trace of the averaging kernel. 
        """
        return _error_analysis.ErrorAnalysis__v_degrees_of_freedom_full_vector(self)


    @property
    def degrees_of_freedom_full_vector(self):
        return self._v_degrees_of_freedom_full_vector()


    def _v_degrees_of_freedom_xco2(self):
        """

        double FullPhysics::ErrorAnalysis::degrees_of_freedom_xco2() const
        Calculate the degrees of freedom for the portion of the state vector
        used to determine xco2. 
        """
        return _error_analysis.ErrorAnalysis__v_degrees_of_freedom_xco2(self)


    @property
    def degrees_of_freedom_xco2(self):
        return self._v_degrees_of_freedom_xco2()


    def _v_xco2_avg_kernel(self):
        """

        Array< double, 1 > ErrorAnalysis::xco2_avg_kernel() const
        Calculate the XCO2 averaging kernel. 
        """
        return _error_analysis.ErrorAnalysis__v_xco2_avg_kernel(self)


    @property
    def xco2_avg_kernel(self):
        return self._v_xco2_avg_kernel()


    def _v_co2_averaging_kernel(self):
        """

        Array< double, 2 > ErrorAnalysis::co2_averaging_kernel() const
        Portion of averaging kernel that relates the part of the state vector
        that is used by the CO2 VMR calculation. 
        """
        return _error_analysis.ErrorAnalysis__v_co2_averaging_kernel(self)


    @property
    def co2_averaging_kernel(self):
        return self._v_co2_averaging_kernel()


    def _v_xco2_avg_kernel_full(self):
        """

        Array< double, 1 > ErrorAnalysis::xco2_avg_kernel_full() const
        This the XCO2 averaging kernel for the full state vector. 
        """
        return _error_analysis.ErrorAnalysis__v_xco2_avg_kernel_full(self)


    @property
    def xco2_avg_kernel_full(self):
        return self._v_xco2_avg_kernel_full()


    def _v_xco2_avg_kernel_norm(self):
        """

        Array< double, 1 > ErrorAnalysis::xco2_avg_kernel_norm() const
        Calculate the normalized XCO2 averaging kernel. 
        """
        return _error_analysis.ErrorAnalysis__v_xco2_avg_kernel_norm(self)


    @property
    def xco2_avg_kernel_norm(self):
        return self._v_xco2_avg_kernel_norm()


    def _v_xco2_correlation_interf(self):
        """

        Array< double, 1 > ErrorAnalysis::xco2_correlation_interf() const
        Calculate xco2_correlation_interf. 
        """
        return _error_analysis.ErrorAnalysis__v_xco2_correlation_interf(self)


    @property
    def xco2_correlation_interf(self):
        return self._v_xco2_correlation_interf()


    def _v_interference_smoothing_uncertainty(self):
        """

        Array< double, 1 > ErrorAnalysis::interference_smoothing_uncertainty() const
        Calculate the interference smoothing uncertainty. 
        """
        return _error_analysis.ErrorAnalysis__v_interference_smoothing_uncertainty(self)


    @property
    def interference_smoothing_uncertainty(self):
        return self._v_interference_smoothing_uncertainty()

    __swig_destroy__ = _error_analysis.delete_ErrorAnalysis
ErrorAnalysis.residual_sum_sq = new_instancemethod(_error_analysis.ErrorAnalysis_residual_sum_sq, None, ErrorAnalysis)
ErrorAnalysis.residual_mean_sq = new_instancemethod(_error_analysis.ErrorAnalysis_residual_mean_sq, None, ErrorAnalysis)
ErrorAnalysis.reduced_chisq = new_instancemethod(_error_analysis.ErrorAnalysis_reduced_chisq, None, ErrorAnalysis)
ErrorAnalysis.relative_residual_mean_sq = new_instancemethod(_error_analysis.ErrorAnalysis_relative_residual_mean_sq, None, ErrorAnalysis)
ErrorAnalysis.signal = new_instancemethod(_error_analysis.ErrorAnalysis_signal, None, ErrorAnalysis)
ErrorAnalysis.noise = new_instancemethod(_error_analysis.ErrorAnalysis_noise, None, ErrorAnalysis)
ErrorAnalysis.chisq_measure_norm = new_instancemethod(_error_analysis.ErrorAnalysis_chisq_measure_norm, None, ErrorAnalysis)
ErrorAnalysis._v_xco2_measurement_error = new_instancemethod(_error_analysis.ErrorAnalysis__v_xco2_measurement_error, None, ErrorAnalysis)
ErrorAnalysis._v_xco2_smoothing_error = new_instancemethod(_error_analysis.ErrorAnalysis__v_xco2_smoothing_error, None, ErrorAnalysis)
ErrorAnalysis._v_xco2_uncertainty = new_instancemethod(_error_analysis.ErrorAnalysis__v_xco2_uncertainty, None, ErrorAnalysis)
ErrorAnalysis._v_xco2_interference_error = new_instancemethod(_error_analysis.ErrorAnalysis__v_xco2_interference_error, None, ErrorAnalysis)
ErrorAnalysis._v_xco2_gain_vector = new_instancemethod(_error_analysis.ErrorAnalysis__v_xco2_gain_vector, None, ErrorAnalysis)
ErrorAnalysis._v_xco2_uncert_noise = new_instancemethod(_error_analysis.ErrorAnalysis__v_xco2_uncert_noise, None, ErrorAnalysis)
ErrorAnalysis._v_xco2_uncert_smooth = new_instancemethod(_error_analysis.ErrorAnalysis__v_xco2_uncert_smooth, None, ErrorAnalysis)
ErrorAnalysis._v_xco2_uncert_interf = new_instancemethod(_error_analysis.ErrorAnalysis__v_xco2_uncert_interf, None, ErrorAnalysis)
ErrorAnalysis._v_degrees_of_freedom_full_vector = new_instancemethod(_error_analysis.ErrorAnalysis__v_degrees_of_freedom_full_vector, None, ErrorAnalysis)
ErrorAnalysis._v_degrees_of_freedom_xco2 = new_instancemethod(_error_analysis.ErrorAnalysis__v_degrees_of_freedom_xco2, None, ErrorAnalysis)
ErrorAnalysis._v_xco2_avg_kernel = new_instancemethod(_error_analysis.ErrorAnalysis__v_xco2_avg_kernel, None, ErrorAnalysis)
ErrorAnalysis._v_co2_averaging_kernel = new_instancemethod(_error_analysis.ErrorAnalysis__v_co2_averaging_kernel, None, ErrorAnalysis)
ErrorAnalysis._v_xco2_avg_kernel_full = new_instancemethod(_error_analysis.ErrorAnalysis__v_xco2_avg_kernel_full, None, ErrorAnalysis)
ErrorAnalysis._v_xco2_avg_kernel_norm = new_instancemethod(_error_analysis.ErrorAnalysis__v_xco2_avg_kernel_norm, None, ErrorAnalysis)
ErrorAnalysis._v_xco2_correlation_interf = new_instancemethod(_error_analysis.ErrorAnalysis__v_xco2_correlation_interf, None, ErrorAnalysis)
ErrorAnalysis._v_interference_smoothing_uncertainty = new_instancemethod(_error_analysis.ErrorAnalysis__v_interference_smoothing_uncertainty, None, ErrorAnalysis)
ErrorAnalysis_swigregister = _error_analysis.ErrorAnalysis_swigregister
ErrorAnalysis_swigregister(ErrorAnalysis)



