# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _nlls_problem.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_nlls_problem')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_nlls_problem')
    _nlls_problem = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_nlls_problem', [dirname(__file__)])
        except ImportError:
            import _nlls_problem
            return _nlls_problem
        try:
            _mod = imp.load_module('_nlls_problem', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _nlls_problem = swig_import_helper()
    del swig_import_helper
else:
    import _nlls_problem
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


try:
    import weakref
    weakref_proxy = weakref.proxy
except __builtin__.Exception:
    weakref_proxy = lambda x: x


SHARED_PTR_DISOWN = _nlls_problem.SHARED_PTR_DISOWN

def _new_from_init(cls, version, *args):
    '''For use with pickle, covers common case where we just store the
    arguments needed to create an object. See for example HdfFile'''
    if(cls.pickle_format_version() != version):
      raise RuntimeException("Class is expecting a pickled object with version number %d, but we found %d" % (cls.pickle_format_version(), version))
    inst = cls.__new__(cls)
    inst.__init__(*args)
    return inst

def _new_from_set(cls, version, *args):
    '''For use with pickle, covers common case where we use a set function 
    to assign the value'''
    if(cls.pickle_format_version() != version):
      raise RuntimeException("Class is expecting a pickled object with version number %d, but we found %d" % (cls.pickle_format_version(), version))
    inst = cls.__new__(cls)
    inst.__init__()
    inst.set(*args)
    return inst

import full_physics_swig.cost_func_diff
import full_physics_swig.cost_func
import full_physics_swig.problem_state
import full_physics_swig.generic_object
class NLLSProblem(full_physics_swig.cost_func_diff.CostFuncDiff):
    """

    The base class for the Non-Linear Least Squares problem.

    The class NLLSProblem is the base class for all problem classes that
    implement a Non-Linear Least Squares (NLLS) problem. The two main
    interface components provided by this class are the residual of the
    problem (a vector function)

    the Jacobian of the residual (the first order derivatives and a matrix
    function)

    A NLLS problem can be solved by NLLS solvers such as the Gauss-Newton
    or the Levenberg-Marquardt methods.

    NLLSProblem implements cost and gradient from its inherited classes;
    therefore, an NLLS problem can also be solved by methods that solve
    optimization problems of CostFunc or CostFuncDiff form.

    A DESIGN RELATED QUESTION:

    Similar to CostFunc and CostFuncDiff, why don't we have a class that
    only adds the residual to the class interface and then derive this
    class from that one to add the Jacobian to the interface as well?

    ANSWER TO THE ABOVE QUESTION:

    As mentioned in the comments of CostFunc, CostFuncDiff and NLLSProblem
    (this) classes, the problems of the forms cost only (CostFunc)

    cost and gradient (CostFuncDiff)

    residual and Jacobian ( NLLSProblem)

    can be solved by certain algorithms. However, there is no method for
    solving a problem of the form residual only

    If the first order derivatives (the Jacobian) of the residual are not
    available, then the problem can be solved only by the methods that
    solve a problem of cost-only (CostFunc) form after converting the
    residual vector function into a cost scalar function using the
    equation \\[ c(x) = \\frac{1}{2}\\parallel f(x) \\parallel^2
    \\]

    C++ includes: nlls_problem.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _nlls_problem.delete_NLLSProblem

    @property
    def cost(self):
        return self._v_cost()


    def _v_residual(self):
        """

        virtual blitz::Array<double, 1> FullPhysics::NLLSProblem::residual()=0
        The residual vector function.

        This method must be implemented by the classes derived from this
        class.

        The parameters (the point in the parameter space) must have already
        been set before calling this method. The parameters are already set if
        one of the following methods is already called successfully:
        parameters() (see ProblemState class)

        cost_x() (see CostFunc class)

        gradient_x() (see CostFuncDiff class)

        cost_gradient_x() (see CostFuncDiff class)

        residual_x()

        jacobian_x()

        residual_jacobian_x()

        If the parameters are already set, then this method returns the
        residual of the NLLS problem at the current set point.

        The size of the residual vector can be obtained in advance by calling
        residual_size().

        The residual of the NLLS problem 
        """
        return _nlls_problem.NLLSProblem__v_residual(self)


    @property
    def residual(self):
        return self._v_residual()


    def residual_x(self, x):
        """

        virtual blitz::Array<double, 1> FullPhysics::NLLSProblem::residual_x(const blitz::Array< double, 1 > &x)
        The residual function with parameters.

        This method also evaluates the residual of the NLLS problem; however,
        it sets the problem at the input new point and then evaluates the
        residual.

        The size of the residual vector can be obtained in advance by calling
        residual_size().

        Parameters:
        -----------

        x:  New set of parameters

        The residual of the cost function 
        """
        return _nlls_problem.NLLSProblem_residual_x(self, x)


    def _v_jacobian(self):
        """

        virtual blitz::Array<double, 2> FullPhysics::NLLSProblem::jacobian()=0
        The Jacobian matrix function.

        This method must be implemented by the classes derived from this
        class.

        The parameters (the point in the parameter space) must have already
        been set before calling this method. The parameters are already set if
        one of the following methods is already called successfully:
        parameters() (see ProblemState class)

        cost_x() (see CostFunc class)

        gradient_x() (see CostFuncDiff class)

        cost_gradient_x() (see CostFuncDiff class)

        residual_x()

        jacobian_x()

        residual_jacobian_x()

        If the parameters are already set, then this method returns the
        Jacobian of the residual of the NLLS problem at the current set point.

        The sizes of the Jacobian matrix can be obtained in advance: The
        number of its rows is the same as residual_size().

        The number of its columns is the same as
        ProblemState::expected_parameter_size() or
        CostFuncDiff::gradient_size()

        The Jacobian of the residual of the NLLS problem 
        """
        return _nlls_problem.NLLSProblem__v_jacobian(self)


    @property
    def jacobian(self):
        return self._v_jacobian()


    def jacobian_x(self, x):
        """

        virtual blitz::Array<double, 2> FullPhysics::NLLSProblem::jacobian_x(const blitz::Array< double, 1 > &x)
        The Jacobian function with parameters.

        This method also evaluates the Jacobian of the residual of the NLLS
        problem; however, it sets the problem at the input new point and then
        evaluates the Jacobian.

        The sizes of the Jacobian matrix can be obtained in advance as
        mentioned in the comments on jacobian() method.

        Parameters:
        -----------

        x:  New set of parameters

        The Jacobian of the residual of the NLLS problem 
        """
        return _nlls_problem.NLLSProblem_jacobian_x(self, x)


    def residual_jacobian(self):
        """

        void NLLSProblem::residual_jacobian(blitz::Array< double, 1 > &r, blitz::Array< double, 2 > &j)
        The residual function and its Jacobian together.

        This method passes to the caller the evaluated residual function and
        its Jacobian at the current set point.

        The parameters (the point in the parameter space) must have already
        been set before calling this method. The parameters are already set if
        one of the following methods is already called successfully:
        parameters() (see ProblemState class)

        cost_x() (see CostFunc class)

        gradient_x()

        cost_gradient_x()

        residual_x()

        jacobian_x()

        residual_jacobian_x()

        Parameters:
        -----------

        r:  The residual vector

        j:  The Jacobian matrix 
        """
        return _nlls_problem.NLLSProblem_residual_jacobian(self)


    def residual_jacobian_x(self, x):
        """

        virtual void FullPhysics::NLLSProblem::residual_jacobian_x(const blitz::Array< double, 1 > &x, blitz::Array< double, 1 > &r,
        blitz::Array< double, 2 > &j)
        The residual and its Jacobian with parameters.

        This method passes to the caller the evaluated residual function and
        its Jacobian after setting the problem at the input new point.

        Parameters:
        -----------

        x:  New set of parameters

        r:  The residual vector

        j:  The Jacobian matrix 
        """
        return _nlls_problem.NLLSProblem_residual_jacobian_x(self, x)


    def _v_num_residual_evaluations(self):
        """

        virtual int FullPhysics::NLLSProblem::num_residual_evaluations() const
        Returns the number of the times residual has been evaluated.

        The number of the times residual has been evaluated 
        """
        return _nlls_problem.NLLSProblem__v_num_residual_evaluations(self)


    @property
    def num_residual_evaluations(self):
        return self._v_num_residual_evaluations()


    def _v_num_jacobian_evaluations(self):
        """

        virtual int FullPhysics::NLLSProblem::num_jacobian_evaluations() const
        Returns the number of the times Jacobian has been evaluated.

        The number of the times Jacobian has been evaluated 
        """
        return _nlls_problem.NLLSProblem__v_num_jacobian_evaluations(self)


    @property
    def num_jacobian_evaluations(self):
        return self._v_num_jacobian_evaluations()


    def _v_residual_size(self):
        """

        virtual int FullPhysics::NLLSProblem::residual_size() const =0
        The size of the residual returned by residual()

        This method must be implemented by the classes derived from this
        class.

        The size of the residual that will be returned by residual() 
        """
        return _nlls_problem.NLLSProblem__v_residual_size(self)


    @property
    def residual_size(self):
        return self._v_residual_size()

NLLSProblem._v_residual = new_instancemethod(_nlls_problem.NLLSProblem__v_residual, None, NLLSProblem)
NLLSProblem.residual_x = new_instancemethod(_nlls_problem.NLLSProblem_residual_x, None, NLLSProblem)
NLLSProblem._v_jacobian = new_instancemethod(_nlls_problem.NLLSProblem__v_jacobian, None, NLLSProblem)
NLLSProblem.jacobian_x = new_instancemethod(_nlls_problem.NLLSProblem_jacobian_x, None, NLLSProblem)
NLLSProblem.residual_jacobian = new_instancemethod(_nlls_problem.NLLSProblem_residual_jacobian, None, NLLSProblem)
NLLSProblem.residual_jacobian_x = new_instancemethod(_nlls_problem.NLLSProblem_residual_jacobian_x, None, NLLSProblem)
NLLSProblem._v_num_residual_evaluations = new_instancemethod(_nlls_problem.NLLSProblem__v_num_residual_evaluations, None, NLLSProblem)
NLLSProblem._v_num_jacobian_evaluations = new_instancemethod(_nlls_problem.NLLSProblem__v_num_jacobian_evaluations, None, NLLSProblem)
NLLSProblem._v_residual_size = new_instancemethod(_nlls_problem.NLLSProblem__v_residual_size, None, NLLSProblem)
NLLSProblem_swigregister = _nlls_problem.NLLSProblem_swigregister
NLLSProblem_swigregister(NLLSProblem)



