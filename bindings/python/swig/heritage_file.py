# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _heritage_file.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_heritage_file')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_heritage_file')
    _heritage_file = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_heritage_file', [dirname(__file__)])
        except ImportError:
            import _heritage_file
            return _heritage_file
        try:
            _mod = imp.load_module('_heritage_file', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _heritage_file = swig_import_helper()
    del swig_import_helper
else:
    import _heritage_file
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


try:
    import weakref
    weakref_proxy = weakref.proxy
except __builtin__.Exception:
    weakref_proxy = lambda x: x


SHARED_PTR_DISOWN = _heritage_file.SHARED_PTR_DISOWN

def _new_from_init(cls, version, *args):
    '''For use with pickle, covers common case where we just store the
    arguments needed to create an object. See for example HdfFile'''
    if(cls.pickle_format_version() != version):
      raise RuntimeException("Class is expecting a pickled object with version number %d, but we found %d" % (cls.pickle_format_version(), version))
    inst = cls.__new__(cls)
    inst.__init__(*args)
    return inst

def _new_from_set(cls, version, *args):
    '''For use with pickle, covers common case where we use a set function 
    to assign the value'''
    if(cls.pickle_format_version() != version):
      raise RuntimeException("Class is expecting a pickled object with version number %d, but we found %d" % (cls.pickle_format_version(), version))
    inst = cls.__new__(cls)
    inst.__init__()
    inst.set(*args)
    return inst

import full_physics_swig.generic_object
class HeritageFile(full_physics_swig.generic_object.GenericObject):
    """

    This class reads the heritage file formats.

    We read both the configuration file and the matrix files (there are
    similar enough in format that it makes sense to combine these two).

    For the configuration files, we provide the values using a "keyword
    path". By convention, this is just the keywords separated by a "/".
    For example, "CONTROL/input_file". Note that the keyword path is
    case insensitive, so "CONTROL/input_file" and "control/INPUT_FILE"
    are the same.

    Some blocks are special in that there can be more than one of them.
    This includes "GAS", "INSTRUMENT", "AEROSOL" and "WINDOW". For
    blocks that we encounter more than one of, we access the data use a
    "index" number, which must be between 0 and the
    number_block(keyword). You can also view this data by adding the name
    to the keyword, so to find the moment file for the aerosol "IC" you
    can look at "PARAMETER_DEFINITION/AEROSOL/IC/moment_file". The two
    interfaces give the same data, use whichever is more convenient.

    For the various "HEADER" format (i.e., the matrix file), we just use
    the keyword with no path, for example "Number_rows".

    We have an blitz Array "double". This is empty unless the file we
    read happens to contain matrix data.

    We support conversion of the values read to a variety of formats. This
    is done by the "value" function. Currently supported conversions:

    Any type that boost::lexical_cast<T> can convert a string to. In
    particular, double and int

    A string. This includes stripping the quotes that may appear around
    the value

    A boolean type. We translate the string "true" to true and "false"
    to false.

    A std::vector<double>, which converts a list of doubles.

    A std::vector<int>, which converts to a list of ints. This supports
    ranges in the entry, e.g. "1:4 7" which is returned as the list 1,
    2, 3, 4, 7.

    A std::vector<std::string>, which converts a set of strings where each
    is quoted.

    A Time for a time stamp.

    Some of the values may be file names. The file and directory names are
    relative to the location of the heritage file. The routine file_value
    handles adding any necessary paths to the values found in the file.

    In addition, file_value will expand out environment variables like
    "$(abscodir)".

    C++ includes: heritage_file.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, Fname):
        """

        HeritageFile::HeritageFile(const std::string &Fname)
        Read the given heritage file. 
        """
        _heritage_file.HeritageFile_swiginit(self, _heritage_file.new_HeritageFile(Fname))

    def parse_file(self, Fname):
        """

        void HeritageFile::parse_file(const std::string &Fname)
        Parse the given file, and add the keyword information from that file
        to the keyword list.

        Read matrix data, if we have any. 
        """
        return _heritage_file.HeritageFile_parse_file(self, Fname)


    @property
    def data(self):
        return self._v_data()


    def column_index(self, Col_name):
        """

        int HeritageFile::column_index(const std::string &Col_name) const
        For files with a Label attribute, this is the index of the named
        column.

        This relies upon having a labels keyword in the file. 
        """
        return _heritage_file.HeritageFile_column_index(self, Col_name)


    def _v_data(self, *args):
        """

        blitz::Array< double, 1 > HeritageFile::data(const std::string &Col_name) const
        For files with a Label attribute, this is the column that has the
        given label. 
        """
        return _heritage_file.HeritageFile__v_data(self, *args)


    def has_value(self, Keyword):
        """

        bool FullPhysics::HeritageFile::has_value(const std::string &Keyword) const
        Return true if we found a value for the given Keyword path. 
        """
        return _heritage_file.HeritageFile_has_value(self, Keyword)

    __swig_destroy__ = _heritage_file.delete_HeritageFile
HeritageFile.__str__ = new_instancemethod(_heritage_file.HeritageFile___str__, None, HeritageFile)
HeritageFile.parse_file = new_instancemethod(_heritage_file.HeritageFile_parse_file, None, HeritageFile)
HeritageFile.column_index = new_instancemethod(_heritage_file.HeritageFile_column_index, None, HeritageFile)
HeritageFile._v_data = new_instancemethod(_heritage_file.HeritageFile__v_data, None, HeritageFile)
HeritageFile.has_value = new_instancemethod(_heritage_file.HeritageFile_has_value, None, HeritageFile)
HeritageFile.value_int = new_instancemethod(_heritage_file.HeritageFile_value_int, None, HeritageFile)
HeritageFile.value_double = new_instancemethod(_heritage_file.HeritageFile_value_double, None, HeritageFile)
HeritageFile.value_string = new_instancemethod(_heritage_file.HeritageFile_value_string, None, HeritageFile)
HeritageFile.value_bool = new_instancemethod(_heritage_file.HeritageFile_value_bool, None, HeritageFile)
HeritageFile.value_string_vector = new_instancemethod(_heritage_file.HeritageFile_value_string_vector, None, HeritageFile)
HeritageFile.value_double_vector = new_instancemethod(_heritage_file.HeritageFile_value_double_vector, None, HeritageFile)
HeritageFile_swigregister = _heritage_file.HeritageFile_swigregister
HeritageFile_swigregister(HeritageFile)



