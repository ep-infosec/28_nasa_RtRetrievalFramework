# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _hdf_file.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_hdf_file')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_hdf_file')
    _hdf_file = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_hdf_file', [dirname(__file__)])
        except ImportError:
            import _hdf_file
            return _hdf_file
        try:
            _mod = imp.load_module('_hdf_file', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _hdf_file = swig_import_helper()
    del swig_import_helper
else:
    import _hdf_file
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


try:
    import weakref
    weakref_proxy = weakref.proxy
except __builtin__.Exception:
    weakref_proxy = lambda x: x


SHARED_PTR_DISOWN = _hdf_file.SHARED_PTR_DISOWN

def _new_from_init(cls, version, *args):
    '''For use with pickle, covers common case where we just store the
    arguments needed to create an object. See for example HdfFile'''
    if(cls.pickle_format_version() != version):
      raise RuntimeException("Class is expecting a pickled object with version number %d, but we found %d" % (cls.pickle_format_version(), version))
    inst = cls.__new__(cls)
    inst.__init__(*args)
    return inst

def _new_from_set(cls, version, *args):
    '''For use with pickle, covers common case where we use a set function 
    to assign the value'''
    if(cls.pickle_format_version() != version):
      raise RuntimeException("Class is expecting a pickled object with version number %d, but we found %d" % (cls.pickle_format_version(), version))
    inst = cls.__new__(cls)
    inst.__init__()
    inst.set(*args)
    return inst

import full_physics_swig.generic_object
class HdfFile(full_physics_swig.generic_object.GenericObject):
    """

    This class reads and writes a HDF5 file.

    Note that this is just a thin layer on top of the HDF 5 libraries to
    make the file operations we need to do in Level 2 Full Physics easier.
    There are many other things that can be done with a HDF 5 than what
    this class exposes.

    Note that because it is what is used by Level 2 product, we produce
    data in 32 bit (either 32 bit integer or 32 bit floating point). On a
    64 bit system, the underlying double and int are larger. We map
    between these types as needed transparently.

    HDF supports both fixed length strings and variable length strings. We
    have the need to write both variable length strings and fixed length
    strings. As a convention, if std::string are passed we write as
    variable length. If const char* is passed, we determine the fixed
    length needed to accommodate the largest string passed and write the
    data as fixed strings of that length (padding shorter strings with
    spaces). This is an arbitrary decision, but it allows us to write both
    types.

    Note that in what is a fairly odd convention, we add a trailing
    '\\0' in our fixed length string, so there is one extra character.

    C++ includes: hdf_file.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    READ = _hdf_file.HdfFile_READ
    CREATE = _hdf_file.HdfFile_CREATE
    READ_WRITE = _hdf_file.HdfFile_READ_WRITE

    def __init__(self, *args):
        """

        HdfFile::HdfFile(const std::string &Fname, Mode M=READ)
        Open the given file with the given mode. 
        """
        _hdf_file.HdfFile_swiginit(self, _hdf_file.new_HdfFile(*args))

    def close(self):
        """

        void FullPhysics::HdfFile::close()
        Close the underlying file.

        This is automatically done by the destructor, so you only need to call
        this if you want to force a close (e.g., for a unit test) 
        """
        return _hdf_file.HdfFile_close(self)


    def has_object(self, Objname):
        """

        bool FullPhysics::HdfFile::has_object(const std::string &Objname) const
        Check to see if an object (such as a Dataset) is in the file. 
        """
        return _hdf_file.HdfFile_has_object(self, Objname)


    def has_attribute(self, Aname):
        """

        bool HdfFile::has_attribute(const std::string &Aname) const
        Check to see if a attribute is in the file.

        Determine if attribute is present. 
        """
        return _hdf_file.HdfFile_has_attribute(self, Aname)


    def _v_file_name(self):
        """

        const std::string& FullPhysics::HdfFile::file_name() const
        File name. 
        """
        return _hdf_file.HdfFile__v_file_name(self)


    @property
    def file_name(self):
        return self._v_file_name()


    def _v_mode(self):
        """

        Mode FullPhysics::HdfFile::mode() const
        Mode file was opened with. 
        """
        return _hdf_file.HdfFile__v_mode(self)


    @property
    def mode(self):
        return self._v_mode()


    def is_hdf(Fname):
        """

        static bool FullPhysics::HdfFile::is_hdf(const std::string &Fname)
        Return true if the given file is an HDF file. 
        """
        return _hdf_file.HdfFile_is_hdf(Fname)

    is_hdf = staticmethod(is_hdf)

    @classmethod
    def pickle_format_version(cls):
      return 1

    def __reduce__(self):
      return _new_from_init, (self.__class__, 1, self.file_name,self.mode)

    __swig_destroy__ = _hdf_file.delete_HdfFile
HdfFile.__str__ = new_instancemethod(_hdf_file.HdfFile___str__, None, HdfFile)
HdfFile.close = new_instancemethod(_hdf_file.HdfFile_close, None, HdfFile)
HdfFile.has_object = new_instancemethod(_hdf_file.HdfFile_has_object, None, HdfFile)
HdfFile.has_attribute = new_instancemethod(_hdf_file.HdfFile_has_attribute, None, HdfFile)
HdfFile._v_file_name = new_instancemethod(_hdf_file.HdfFile__v_file_name, None, HdfFile)
HdfFile._v_mode = new_instancemethod(_hdf_file.HdfFile__v_mode, None, HdfFile)
HdfFile.write_double_1d = new_instancemethod(_hdf_file.HdfFile_write_double_1d, None, HdfFile)
HdfFile.write_double_2d = new_instancemethod(_hdf_file.HdfFile_write_double_2d, None, HdfFile)
HdfFile.write_double_3d = new_instancemethod(_hdf_file.HdfFile_write_double_3d, None, HdfFile)
HdfFile.write_double_4d = new_instancemethod(_hdf_file.HdfFile_write_double_4d, None, HdfFile)
HdfFile.read_double_1d = new_instancemethod(_hdf_file.HdfFile_read_double_1d, None, HdfFile)
HdfFile.read_double_2d = new_instancemethod(_hdf_file.HdfFile_read_double_2d, None, HdfFile)
HdfFile.read_double_3d = new_instancemethod(_hdf_file.HdfFile_read_double_3d, None, HdfFile)
HdfFile.read_double_4d = new_instancemethod(_hdf_file.HdfFile_read_double_4d, None, HdfFile)
HdfFile.read_int_1d = new_instancemethod(_hdf_file.HdfFile_read_int_1d, None, HdfFile)
HdfFile.read_int_2d = new_instancemethod(_hdf_file.HdfFile_read_int_2d, None, HdfFile)
HdfFile.read_int_3d = new_instancemethod(_hdf_file.HdfFile_read_int_3d, None, HdfFile)
HdfFile.read_int_4d = new_instancemethod(_hdf_file.HdfFile_read_int_4d, None, HdfFile)
HdfFile.read_double_with_unit_1d = new_instancemethod(_hdf_file.HdfFile_read_double_with_unit_1d, None, HdfFile)
HdfFile.read_double_with_unit_2d = new_instancemethod(_hdf_file.HdfFile_read_double_with_unit_2d, None, HdfFile)
HdfFile.read_double_with_unit_3d = new_instancemethod(_hdf_file.HdfFile_read_double_with_unit_3d, None, HdfFile)
HdfFile.read_double_with_unit_4d = new_instancemethod(_hdf_file.HdfFile_read_double_with_unit_4d, None, HdfFile)
HdfFile_swigregister = _hdf_file.HdfFile_swigregister
HdfFile_swigregister(HdfFile)

def HdfFile_is_hdf(Fname):
    """

    static bool FullPhysics::HdfFile::is_hdf(const std::string &Fname)
    Return true if the given file is an HDF file. 
    """
    return _hdf_file.HdfFile_is_hdf(Fname)



