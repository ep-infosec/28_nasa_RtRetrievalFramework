# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _output.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_output')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_output')
    _output = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_output', [dirname(__file__)])
        except ImportError:
            import _output
            return _output
        try:
            _mod = imp.load_module('_output', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _output = swig_import_helper()
    del swig_import_helper
else:
    import _output
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


try:
    import weakref
    weakref_proxy = weakref.proxy
except __builtin__.Exception:
    weakref_proxy = lambda x: x


SHARED_PTR_DISOWN = _output.SHARED_PTR_DISOWN

def _new_from_init(cls, version, *args):
    '''For use with pickle, covers common case where we just store the
    arguments needed to create an object. See for example HdfFile'''
    if(cls.pickle_format_version() != version):
      raise RuntimeException("Class is expecting a pickled object with version number %d, but we found %d" % (cls.pickle_format_version(), version))
    inst = cls.__new__(cls)
    inst.__init__(*args)
    return inst

def _new_from_set(cls, version, *args):
    '''For use with pickle, covers common case where we use a set function 
    to assign the value'''
    if(cls.pickle_format_version() != version):
      raise RuntimeException("Class is expecting a pickled object with version number %d, but we found %d" % (cls.pickle_format_version(), version))
    inst = cls.__new__(cls)
    inst.__init__()
    inst.set(*args)
    return inst

import full_physics_swig.generic_object
class OutputDouble(full_physics_swig.generic_object.GenericObject):
    """

    C++ includes: output.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        """

        FullPhysics::OutputDouble::OutputDouble()

        """
        if self.__class__ == OutputDouble:
            _self = None
        else:
            _self = self
        _output.OutputDouble_swiginit(self, _output.new_OutputDouble(_self, ))
    __swig_destroy__ = _output.delete_OutputDouble

    def f(self):
        """

        virtual double FullPhysics::OutputDouble::f() const =0

        """
        return _output.OutputDouble_f(self)

    def __disown__(self):
        self.this.disown()
        _output.disown_OutputDouble(self)
        return weakref_proxy(self)
OutputDouble.f = new_instancemethod(_output.OutputDouble_f, None, OutputDouble)
OutputDouble_swigregister = _output.OutputDouble_swigregister
OutputDouble_swigregister(OutputDouble)

class OutputBlitz1d(full_physics_swig.generic_object.GenericObject):
    """

    C++ includes: output.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        """

        FullPhysics::OutputBlitz1d::OutputBlitz1d()

        """
        if self.__class__ == OutputBlitz1d:
            _self = None
        else:
            _self = self
        _output.OutputBlitz1d_swiginit(self, _output.new_OutputBlitz1d(_self, ))
    __swig_destroy__ = _output.delete_OutputBlitz1d

    def f(self):
        """

        virtual blitz::Array<double,1> FullPhysics::OutputBlitz1d::f() const =0

        """
        return _output.OutputBlitz1d_f(self)

    def __disown__(self):
        self.this.disown()
        _output.disown_OutputBlitz1d(self)
        return weakref_proxy(self)
OutputBlitz1d.f = new_instancemethod(_output.OutputBlitz1d_f, None, OutputBlitz1d)
OutputBlitz1d_swigregister = _output.OutputBlitz1d_swigregister
OutputBlitz1d_swigregister(OutputBlitz1d)

class OutputBlitz2d(full_physics_swig.generic_object.GenericObject):
    """

    C++ includes: output.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        """

        FullPhysics::OutputBlitz2d::OutputBlitz2d()

        """
        if self.__class__ == OutputBlitz2d:
            _self = None
        else:
            _self = self
        _output.OutputBlitz2d_swiginit(self, _output.new_OutputBlitz2d(_self, ))
    __swig_destroy__ = _output.delete_OutputBlitz2d

    def f(self):
        """

        virtual blitz::Array<double,2> FullPhysics::OutputBlitz2d::f() const =0

        """
        return _output.OutputBlitz2d_f(self)

    def __disown__(self):
        self.this.disown()
        _output.disown_OutputBlitz2d(self)
        return weakref_proxy(self)
OutputBlitz2d.f = new_instancemethod(_output.OutputBlitz2d_f, None, OutputBlitz2d)
OutputBlitz2d_swigregister = _output.OutputBlitz2d_swigregister
OutputBlitz2d_swigregister(OutputBlitz2d)


class OutputDoubleWrap(OutputDouble):
    def __init__(self, func):
        OutputDouble.__init__(self)
        self.func = func

    def f(self):
        return self.func()

class OutputBlitz1dWrap(OutputBlitz1d):
    def __init__(self, func):
        OutputBlitz1d.__init__(self)
        self.func = func

    def f(self):
        return self.func()

class OutputBlitz2dWrap(OutputBlitz2d):
    def __init__(self, func):
        OutputBlitz2d.__init__(self)
        self.func = func

    def f(self):
        return self.func()


class Output(object):
    """

    This is the base class for classes that write output for Level 2 Full
    Physics.

    Specific derived classes are used to write out files (e.g., OutputHdf,
    OutputHeritage), this class just captures the common behavior.

    The output is designed to be decentralized. Classes register
    themselves as being able to supply data to be written out when
    requested, and the OutputHeritage class will request this data when it
    wants to write out the state of the system. This "write on demand"
    design allows for scenarios such as "dump data out when an error
    occurs" and "dump data on each iteration of the retrieval solver",
    and "checkpoint results".

    In many cases, the dataset and metadata is supplied either as a
    constant unchanging value, or as a pointer to a member function of an
    object supplied as a boost::shared_ptr<T>. The functions
    "register_data_source" have been overloaded to handle these common
    cases, most of the time these are the only functions you need. If you
    want to specify this with a more general boost::function, you can do
    so also.

    The derived class need to supply various write_xxx functions to act as
    a data sink for this data.

    This class only supports a fixed number of data types (int, double,
    std::string) and array rank (scalar, 1d, 2d, 3d). We also have a
    int64_t scalar, needed for the sounding id. We can easily extend this
    to other types and ranks if needed. For developers, you add a new
    types by adding a new write_data function to this class, along with
    adding the type to function "pass_to_write".

    A write is intended to be atomic - either it completely succeeds or
    the output should be cleaned up and nothing produced. This prevents a
    file with "missing fields" from being generated.

    In the case of a processing error, we may want to make an attempt to
    dump as much of the data as possible to help with diagnostics. A
    separate "write_best_attempt" routines is supplied, this will write
    out whatever we can, ignoring all errors. This can results in partial
    files, but in the case of a diagnostic file whatever we can get is
    better than nothing.

    C++ includes: output.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _output.delete_Output

    def write(self):
        """

        void Output::write()
        Write out file.

        A write is intended to be atomic - either it completely succeeds or
        the output should be cleaned up and nothing produced. This prevents a
        file with "missing fields" from being generated. 
        """
        return _output.Output_write(self)


    def write_best_attempt(self):
        """

        void Output::write_best_attempt()
        Write out the file, making a best attempt but ignoring all errors.

        This may result in a file that is missing fields that had an error
        when writing or collecting the data. This is intended for use by an
        error dump, when we want to get whatever we can. 
        """
        return _output.Output_write_best_attempt(self)


    def register_double(self, nm, f):
        self._register_data_source(nm, OutputDoubleWrap(f))

    def register_array_1d(self, nm, f):
        self._register_data_source(nm, OutputBlitz1dWrap(f))

    def register_array_2d(self, nm, f):
        self._register_data_source(nm, OutputBlitz2dWrap(f))

Output.__str__ = new_instancemethod(_output.Output___str__, None, Output)
Output.write = new_instancemethod(_output.Output_write, None, Output)
Output.write_best_attempt = new_instancemethod(_output.Output_write_best_attempt, None, Output)
Output._register_data_source = new_instancemethod(_output.Output__register_data_source, None, Output)
Output_swigregister = _output.Output_swigregister
Output_swigregister(Output)



