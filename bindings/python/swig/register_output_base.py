# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _register_output_base.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_register_output_base')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_register_output_base')
    _register_output_base = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_register_output_base', [dirname(__file__)])
        except ImportError:
            import _register_output_base
            return _register_output_base
        try:
            _mod = imp.load_module('_register_output_base', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _register_output_base = swig_import_helper()
    del swig_import_helper
else:
    import _register_output_base
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


try:
    import weakref
    weakref_proxy = weakref.proxy
except __builtin__.Exception:
    weakref_proxy = lambda x: x


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _register_output_base.delete_SwigPyIterator
    def __iter__(self):
        return self
SwigPyIterator.value = new_instancemethod(_register_output_base.SwigPyIterator_value, None, SwigPyIterator)
SwigPyIterator.incr = new_instancemethod(_register_output_base.SwigPyIterator_incr, None, SwigPyIterator)
SwigPyIterator.decr = new_instancemethod(_register_output_base.SwigPyIterator_decr, None, SwigPyIterator)
SwigPyIterator.distance = new_instancemethod(_register_output_base.SwigPyIterator_distance, None, SwigPyIterator)
SwigPyIterator.equal = new_instancemethod(_register_output_base.SwigPyIterator_equal, None, SwigPyIterator)
SwigPyIterator.copy = new_instancemethod(_register_output_base.SwigPyIterator_copy, None, SwigPyIterator)
SwigPyIterator.next = new_instancemethod(_register_output_base.SwigPyIterator_next, None, SwigPyIterator)
SwigPyIterator.__next__ = new_instancemethod(_register_output_base.SwigPyIterator___next__, None, SwigPyIterator)
SwigPyIterator.previous = new_instancemethod(_register_output_base.SwigPyIterator_previous, None, SwigPyIterator)
SwigPyIterator.advance = new_instancemethod(_register_output_base.SwigPyIterator_advance, None, SwigPyIterator)
SwigPyIterator.__eq__ = new_instancemethod(_register_output_base.SwigPyIterator___eq__, None, SwigPyIterator)
SwigPyIterator.__ne__ = new_instancemethod(_register_output_base.SwigPyIterator___ne__, None, SwigPyIterator)
SwigPyIterator.__iadd__ = new_instancemethod(_register_output_base.SwigPyIterator___iadd__, None, SwigPyIterator)
SwigPyIterator.__isub__ = new_instancemethod(_register_output_base.SwigPyIterator___isub__, None, SwigPyIterator)
SwigPyIterator.__add__ = new_instancemethod(_register_output_base.SwigPyIterator___add__, None, SwigPyIterator)
SwigPyIterator.__sub__ = new_instancemethod(_register_output_base.SwigPyIterator___sub__, None, SwigPyIterator)
SwigPyIterator_swigregister = _register_output_base.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

SHARED_PTR_DISOWN = _register_output_base.SHARED_PTR_DISOWN

def _new_from_init(cls, version, *args):
    '''For use with pickle, covers common case where we just store the
    arguments needed to create an object. See for example HdfFile'''
    if(cls.pickle_format_version() != version):
      raise RuntimeException("Class is expecting a pickled object with version number %d, but we found %d" % (cls.pickle_format_version(), version))
    inst = cls.__new__(cls)
    inst.__init__(*args)
    return inst

def _new_from_set(cls, version, *args):
    '''For use with pickle, covers common case where we use a set function 
    to assign the value'''
    if(cls.pickle_format_version() != version):
      raise RuntimeException("Class is expecting a pickled object with version number %d, but we found %d" % (cls.pickle_format_version(), version))
    inst = cls.__new__(cls)
    inst.__init__()
    inst.set(*args)
    return inst

import full_physics_swig.generic_object
class RegisterOutputBase(object):
    """

    As described in the Output class, we have a decentralized model of
    producing output for L2 Full Physics.

    Rather than directly writing a value to a file, we register functions
    that can supply the values when requested. This has the advantage of
    keeping everything in sync we don't have values written out from
    earlier iterations of the algorithm.

    There isn't anything particularly special to register a function, just
    a call to Output::register_data_source. However as a matter of
    convention we collect all the functions that register data into
    classes found in the RegisterOutput directory, and derived from this
    RegisterOutputBase class. This class doesn't really give any special
    functionality, rather deriving from this class is a statement of
    intent that derived classes what to register output.

    A reasonable implementation would be to have classes that supply
    output data register there intent themselves, so for example
    Atmosphere could have register_output function. However this would
    then couple these classes with our particular output model. You could
    imagine reusing Atmosphere class in other contexts which do not want
    to use this particular output model. So again as a matter of
    convention we use a separate class to register output, in this case
    AtmosphereOutput. We may decide at some point that these extra classes
    are unnecessarily complicated design, but for now we'll keep this
    division.

    For many classes, we output different information for apriori state
    vector value vs. the final state vector value. So the registration is
    separated as two functions. Alternatively, we could have just had two
    different registration classes, but this is the way we've chosen.

    Note that by convention that we "freeze" the state of the class when
    we register the apriori_output. This allows for things like the
    StateVector to be changed after wards without changing the apriori
    state.

    C++ includes: register_output_base.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    __swig_destroy__ = _register_output_base.delete_RegisterOutputBase

    def desc(self):
        """

        virtual std::string FullPhysics::RegisterOutputBase::desc() const
        Description of object, to be printed to stream.

        This gives a cleaner interface for deriving from python. 
        """
        return _register_output_base.RegisterOutputBase_desc(self)


    def register_output(self, out):
        """

        virtual void FullPhysics::RegisterOutputBase::register_output(const boost::shared_ptr< Output > &out) const =0
        Register portions of class that will be written to output.

        This is for the final statevector, for classes where apriori and final
        are written out different. 
        """
        return _register_output_base.RegisterOutputBase_register_output(self, out)


    def register_output_apriori(self, out):
        """

        virtual void FullPhysics::RegisterOutputBase::register_output_apriori(const boost::shared_ptr< Output > &out) const
        Register apriori portions of class.

        The default is not to have anything written out, but derived classes
        can override this.

        Note that by convention that we "freeze" the state of the class when
        we register the apriori_output. This allows for things like the
        StateVector to be changed after wards without changing the apriori
        state. 
        """
        return _register_output_base.RegisterOutputBase_register_output_apriori(self, out)


    def __init__(self):
        if self.__class__ == RegisterOutputBase:
            _self = None
        else:
            _self = self
        _register_output_base.RegisterOutputBase_swiginit(self, _register_output_base.new_RegisterOutputBase(_self, ))
    def __disown__(self):
        self.this.disown()
        _register_output_base.disown_RegisterOutputBase(self)
        return weakref_proxy(self)
RegisterOutputBase.__str__ = new_instancemethod(_register_output_base.RegisterOutputBase___str__, None, RegisterOutputBase)
RegisterOutputBase.desc = new_instancemethod(_register_output_base.RegisterOutputBase_desc, None, RegisterOutputBase)
RegisterOutputBase.register_output = new_instancemethod(_register_output_base.RegisterOutputBase_register_output, None, RegisterOutputBase)
RegisterOutputBase.register_output_apriori = new_instancemethod(_register_output_base.RegisterOutputBase_register_output_apriori, None, RegisterOutputBase)
RegisterOutputBase_swigregister = _register_output_base.RegisterOutputBase_swigregister
RegisterOutputBase_swigregister(RegisterOutputBase)

class vector_register_output(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __iter__(self):
        return self.iterator()

    def __init__(self, *args):
        _register_output_base.vector_register_output_swiginit(self, _register_output_base.new_vector_register_output(*args))
    __swig_destroy__ = _register_output_base.delete_vector_register_output
vector_register_output.iterator = new_instancemethod(_register_output_base.vector_register_output_iterator, None, vector_register_output)
vector_register_output.__nonzero__ = new_instancemethod(_register_output_base.vector_register_output___nonzero__, None, vector_register_output)
vector_register_output.__bool__ = new_instancemethod(_register_output_base.vector_register_output___bool__, None, vector_register_output)
vector_register_output.__len__ = new_instancemethod(_register_output_base.vector_register_output___len__, None, vector_register_output)
vector_register_output.__getslice__ = new_instancemethod(_register_output_base.vector_register_output___getslice__, None, vector_register_output)
vector_register_output.__setslice__ = new_instancemethod(_register_output_base.vector_register_output___setslice__, None, vector_register_output)
vector_register_output.__delslice__ = new_instancemethod(_register_output_base.vector_register_output___delslice__, None, vector_register_output)
vector_register_output.__delitem__ = new_instancemethod(_register_output_base.vector_register_output___delitem__, None, vector_register_output)
vector_register_output.__getitem__ = new_instancemethod(_register_output_base.vector_register_output___getitem__, None, vector_register_output)
vector_register_output.__setitem__ = new_instancemethod(_register_output_base.vector_register_output___setitem__, None, vector_register_output)
vector_register_output.pop = new_instancemethod(_register_output_base.vector_register_output_pop, None, vector_register_output)
vector_register_output.append = new_instancemethod(_register_output_base.vector_register_output_append, None, vector_register_output)
vector_register_output.empty = new_instancemethod(_register_output_base.vector_register_output_empty, None, vector_register_output)
vector_register_output.size = new_instancemethod(_register_output_base.vector_register_output_size, None, vector_register_output)
vector_register_output.swap = new_instancemethod(_register_output_base.vector_register_output_swap, None, vector_register_output)
vector_register_output.begin = new_instancemethod(_register_output_base.vector_register_output_begin, None, vector_register_output)
vector_register_output.end = new_instancemethod(_register_output_base.vector_register_output_end, None, vector_register_output)
vector_register_output.rbegin = new_instancemethod(_register_output_base.vector_register_output_rbegin, None, vector_register_output)
vector_register_output.rend = new_instancemethod(_register_output_base.vector_register_output_rend, None, vector_register_output)
vector_register_output.clear = new_instancemethod(_register_output_base.vector_register_output_clear, None, vector_register_output)
vector_register_output.get_allocator = new_instancemethod(_register_output_base.vector_register_output_get_allocator, None, vector_register_output)
vector_register_output.pop_back = new_instancemethod(_register_output_base.vector_register_output_pop_back, None, vector_register_output)
vector_register_output.erase = new_instancemethod(_register_output_base.vector_register_output_erase, None, vector_register_output)
vector_register_output.push_back = new_instancemethod(_register_output_base.vector_register_output_push_back, None, vector_register_output)
vector_register_output.front = new_instancemethod(_register_output_base.vector_register_output_front, None, vector_register_output)
vector_register_output.back = new_instancemethod(_register_output_base.vector_register_output_back, None, vector_register_output)
vector_register_output.assign = new_instancemethod(_register_output_base.vector_register_output_assign, None, vector_register_output)
vector_register_output.resize = new_instancemethod(_register_output_base.vector_register_output_resize, None, vector_register_output)
vector_register_output.insert = new_instancemethod(_register_output_base.vector_register_output_insert, None, vector_register_output)
vector_register_output.reserve = new_instancemethod(_register_output_base.vector_register_output_reserve, None, vector_register_output)
vector_register_output.capacity = new_instancemethod(_register_output_base.vector_register_output_capacity, None, vector_register_output)
vector_register_output_swigregister = _register_output_base.vector_register_output_swigregister
vector_register_output_swigregister(vector_register_output)



