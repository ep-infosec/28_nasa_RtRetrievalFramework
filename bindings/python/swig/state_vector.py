# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _state_vector.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_state_vector')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_state_vector')
    _state_vector = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_state_vector', [dirname(__file__)])
        except ImportError:
            import _state_vector
            return _state_vector
        try:
            _mod = imp.load_module('_state_vector', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _state_vector = swig_import_helper()
    del swig_import_helper
else:
    import _state_vector
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


try:
    import weakref
    weakref_proxy = weakref.proxy
except __builtin__.Exception:
    weakref_proxy = lambda x: x


SHARED_PTR_DISOWN = _state_vector.SHARED_PTR_DISOWN

def _new_from_init(cls, version, *args):
    '''For use with pickle, covers common case where we just store the
    arguments needed to create an object. See for example HdfFile'''
    if(cls.pickle_format_version() != version):
      raise RuntimeException("Class is expecting a pickled object with version number %d, but we found %d" % (cls.pickle_format_version(), version))
    inst = cls.__new__(cls)
    inst.__init__(*args)
    return inst

def _new_from_set(cls, version, *args):
    '''For use with pickle, covers common case where we use a set function 
    to assign the value'''
    if(cls.pickle_format_version() != version):
      raise RuntimeException("Class is expecting a pickled object with version number %d, but we found %d" % (cls.pickle_format_version(), version))
    inst = cls.__new__(cls)
    inst.__init__()
    inst.set(*args)
    return inst

import full_physics_swig.generic_object
class ObserverStateVector(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        if self.__class__ == ObserverStateVector:
            _self = None
        else:
            _self = self
        _state_vector.ObserverStateVector_swiginit(self, _state_vector.new_ObserverStateVector(_self, ))
    def __disown__(self):
        self.this.disown()
        _state_vector.disown_ObserverStateVector(self)
        return weakref_proxy(self)
ObserverStateVector.notify_add = new_instancemethod(_state_vector.ObserverStateVector_notify_add, None, ObserverStateVector)
ObserverStateVector.notify_remove = new_instancemethod(_state_vector.ObserverStateVector_notify_remove, None, ObserverStateVector)
ObserverStateVector.notify_update = new_instancemethod(_state_vector.ObserverStateVector_notify_update, None, ObserverStateVector)
ObserverStateVector_swigregister = _state_vector.ObserverStateVector_swigregister
ObserverStateVector_swigregister(ObserverStateVector)

class ObservableStateVector(full_physics_swig.generic_object.GenericObject):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _state_vector.delete_ObservableStateVector
ObservableStateVector.add_observer_and_keep_reference = new_instancemethod(_state_vector.ObservableStateVector_add_observer_and_keep_reference, None, ObservableStateVector)
ObservableStateVector.add_observer = new_instancemethod(_state_vector.ObservableStateVector_add_observer, None, ObservableStateVector)
ObservableStateVector.remove_observer = new_instancemethod(_state_vector.ObservableStateVector_remove_observer, None, ObservableStateVector)
ObservableStateVector_swigregister = _state_vector.ObservableStateVector_swigregister
ObservableStateVector_swigregister(ObservableStateVector)

class StateVectorObserver(ObserverStateVector):
    """

    This is an observer of a StateVector.

    If attached to a StateVector, this class gets notified when a state
    vector is updated.

    It is completely unspecified what an observer does with this
    information, but commonly the class will update its internal state
    based on the state vector update.

    C++ includes: state_vector.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _state_vector.delete_StateVectorObserver

    def mark_used(self, Sv, Used):
        """

        virtual void FullPhysics::StateVectorObserver::mark_used(const StateVector &Sv, blitz::Array< bool, 1 > &Used) const
        Mark elements that we are actively using (i.e., that aren't ignored).

        You only need to mark the ones that are used as true, everything is
        already initialized as false. Default is to do nothing. 
        """
        return _state_vector.StateVectorObserver_mark_used(self, Sv, Used)


    def state_vector_name(self, Sv, Sv_name):
        """

        virtual void FullPhysics::StateVectorObserver::state_vector_name(const StateVector &Sv, blitz::Array< std::string, 1 > &Sv_name) const
        Update any portion of the list of the state vector names that apply to
        this object.

        Default is to do nothing. 
        """
        return _state_vector.StateVectorObserver_state_vector_name(self, Sv, Sv_name)

StateVectorObserver.__str__ = new_instancemethod(_state_vector.StateVectorObserver___str__, None, StateVectorObserver)
StateVectorObserver.mark_used = new_instancemethod(_state_vector.StateVectorObserver_mark_used, None, StateVectorObserver)
StateVectorObserver.state_vector_name = new_instancemethod(_state_vector.StateVectorObserver_state_vector_name, None, StateVectorObserver)
StateVectorObserver_swigregister = _state_vector.StateVectorObserver_swigregister
StateVectorObserver_swigregister(StateVectorObserver)

class StateVector(ObservableStateVector):
    """

    This handles informing a set of interested objects when the state
    vector has updated.

    Those objects then update their internal state to account for the new
    state vector.

    C++ includes: state_vector.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    __swig_destroy__ = _state_vector.delete_StateVector

    def __init__(self):
        """

        FullPhysics::StateVector::StateVector()

        """
        _state_vector.StateVector_swiginit(self, _state_vector.new_StateVector())

    def _v_state(self):
        """

        const blitz::Array<double, 1>& FullPhysics::StateVector::state() const
        Current state vector. 
        """
        return _state_vector.StateVector__v_state(self)


    @property
    def state(self):
        return self._v_state()


    def _v_state_with_derivative(self):
        """

        const ArrayAd<double, 1>& FullPhysics::StateVector::state_with_derivative() const
        Return the state vector as state() does, but also make each value a
        AutoDerivative.

        The derivative is with respect to the state vector, i.e., we treat the
        state vector as the independent variables. This means the first value
        has a gradient all 0's except for 1 in the first index, the second
        value all zeros except for 1 in the second index, etc. 
        """
        return _state_vector.StateVector__v_state_with_derivative(self)


    @property
    def state_with_derivative(self):
        return self._v_state_with_derivative()


    @property
    def state_vector_name(self):
        return self._state_vector_name()


    def _v_state_covariance(self):
        """

        const blitz::Array<double, 2>& FullPhysics::StateVector::state_covariance() const
        Current covariance of the state vector. 
        """
        return _state_vector.StateVector__v_state_covariance(self)


    @property
    def state_covariance(self):
        return self._v_state_covariance()


    def update_state(self, *args):
        """

        void StateVector::update_state(const blitz::Array< double, 1 > &X, const blitz::Array< double, 2 >
        &Cov)
        Update the state vector and covariance. 
        """
        return _state_vector.StateVector_update_state(self, *args)


    def _v_used_flag(self):
        """

        blitz::Array< bool, 1 > StateVector::used_flag() const
        Return a Array of boolean values.

        The value (i) is true if the state vector element X(i) is being used.
        This can be used to determine parameters that are being ignored, e.g.
        the number of active levels in an Aerosol is less that the size of the
        state vector for it. 
        """
        return _state_vector.StateVector__v_used_flag(self)


    @property
    def used_flag(self):
        return self._v_used_flag()


    def _v_observer_claimed_size(self, *args):
        """

        void FullPhysics::StateVector::observer_claimed_size(int Pstart)
        Update claimed size of state vector. 
        """
        return _state_vector.StateVector__v_observer_claimed_size(self, *args)


    @property
    def observer_claimed_size(self):
        return self._v_observer_claimed_size()

    @observer_claimed_size.setter
    def observer_claimed_size(self, value):
      self._v_observer_claimed_size(value)

StateVector.__str__ = new_instancemethod(_state_vector.StateVector___str__, None, StateVector)
StateVector._v_state = new_instancemethod(_state_vector.StateVector__v_state, None, StateVector)
StateVector._v_state_with_derivative = new_instancemethod(_state_vector.StateVector__v_state_with_derivative, None, StateVector)
StateVector._state_vector_name = new_instancemethod(_state_vector.StateVector__state_vector_name, None, StateVector)
StateVector._v_state_covariance = new_instancemethod(_state_vector.StateVector__v_state_covariance, None, StateVector)
StateVector.update_state = new_instancemethod(_state_vector.StateVector_update_state, None, StateVector)
StateVector._v_used_flag = new_instancemethod(_state_vector.StateVector__v_used_flag, None, StateVector)
StateVector._v_observer_claimed_size = new_instancemethod(_state_vector.StateVector__v_observer_claimed_size, None, StateVector)
StateVector_swigregister = _state_vector.StateVector_swigregister
StateVector_swigregister(StateVector)

class SubStateVectorObserver(StateVectorObserver):
    """

    A common StateVectorObserver just "owns" a subset of the
    StateVector.

    This class gives the common behavior for this case.

    C++ includes: state_vector.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _state_vector.delete_SubStateVectorObserver

    def _v_state_vector_start_index(self):
        """

        int FullPhysics::SubStateVectorObserver::state_vector_start_index() const
        Starting index of state vector used by this object. 
        """
        return _state_vector.SubStateVectorObserver__v_state_vector_start_index(self)


    @property
    def state_vector_start_index(self):
        return self._v_state_vector_start_index()


    def _v_sub_vector_size(self):
        """

        int FullPhysics::SubStateVectorObserver::sub_vector_size() const
        Length of the sub set of the state vector used by this object. 
        """
        return _state_vector.SubStateVectorObserver__v_sub_vector_size(self)


    @property
    def sub_vector_size(self):
        return self._v_sub_vector_size()


    def update_sub_state(self, Sv_sub, Cov_sub):
        """

        virtual void FullPhysics::SubStateVectorObserver::update_sub_state(const ArrayAd< double, 1 > &Sv_sub, const blitz::Array< double, 2 >
        &Cov_sub)=0
        Called by update_state with the subset of the state vector used by
        this class. 
        """
        return _state_vector.SubStateVectorObserver_update_sub_state(self, Sv_sub, Cov_sub)


    def mark_used_sub(self, Used):
        """

        virtual void FullPhysics::SubStateVectorObserver::mark_used_sub(blitz::Array< bool, 1 > &Used) const
        Called by mark_used with the subset of the state vector used by this
        class.

        The default marks everything as used, but derived classes can override
        this. 
        """
        return _state_vector.SubStateVectorObserver_mark_used_sub(self, Used)


    def state_vector_name_sub(self, Sv_name):
        """

        virtual void FullPhysics::SubStateVectorObserver::state_vector_name_sub(blitz::Array< std::string, 1 > &Sv_name) const
        Called by state_vector_name with the subset of the Sv_name used by
        this class.

        The default function doesn't change anything, but derived classes can
        ovveride this. 
        """
        return _state_vector.SubStateVectorObserver_state_vector_name_sub(self, Sv_name)


    def print_desc(self, Os):
        """

        virtual void FullPhysics::SubStateVectorObserver::print(std::ostream &Os) const

        """
        return _state_vector.SubStateVectorObserver_print_desc(self, Os)

SubStateVectorObserver._v_state_vector_start_index = new_instancemethod(_state_vector.SubStateVectorObserver__v_state_vector_start_index, None, SubStateVectorObserver)
SubStateVectorObserver._v_sub_vector_size = new_instancemethod(_state_vector.SubStateVectorObserver__v_sub_vector_size, None, SubStateVectorObserver)
SubStateVectorObserver.update_sub_state = new_instancemethod(_state_vector.SubStateVectorObserver_update_sub_state, None, SubStateVectorObserver)
SubStateVectorObserver.mark_used_sub = new_instancemethod(_state_vector.SubStateVectorObserver_mark_used_sub, None, SubStateVectorObserver)
SubStateVectorObserver.state_vector_name_sub = new_instancemethod(_state_vector.SubStateVectorObserver_state_vector_name_sub, None, SubStateVectorObserver)
SubStateVectorObserver.print_desc = new_instancemethod(_state_vector.SubStateVectorObserver_print_desc, None, SubStateVectorObserver)
SubStateVectorObserver_swigregister = _state_vector.SubStateVectorObserver_swigregister
SubStateVectorObserver_swigregister(SubStateVectorObserver)



